//===========================================================	//===========================================================
// Athena++ astrophysical MHD code				// Athena++ astrophysical MHD code
// Copyright(C) 2014 James M. Stone <jmstone@princeton.edu> a	// Copyright(C) 2014 James M. Stone <jmstone@princeton.edu> a
// Licensed under the 3-clause BSD License, see LICENSE file 	// Licensed under the 3-clause BSD License, see LICENSE file 
//===========================================================	//===========================================================
//! \file parker_my_IC.cpp					//! \file parker_my_IC.cpp
//  \brief Problem generator for Parker wind.			//  \brief Problem generator for Parker wind.
//								//


#define COMP_DT 1    // Compute hydro time-steps and save to 	#define COMP_DT 1    // Compute hydro time-steps and save to 

// C/C++ headers						// C/C++ headers
#include <algorithm>  // min, max				#include <algorithm>  // min, max
#include <cmath>						#include <cmath>
#include <cstdlib>						#include <cstdlib>
#include <fstream>						#include <fstream>
#include <iostream>						#include <iostream>
#include <limits>   // std::numeric_limits<float>::epsilon()	#include <limits>   // std::numeric_limits<float>::epsilon()
#include <sstream>						#include <sstream>
#include <string>						#include <string>
// Athena++ headers						// Athena++ headers
#include "../athena.hpp"					#include "../athena.hpp"
#include "../athena_arrays.hpp"					#include "../athena_arrays.hpp"
#include "../coordinates/coordinates.hpp"			#include "../coordinates/coordinates.hpp"
#include "../eos/eos.hpp"					#include "../eos/eos.hpp"
#include "../field/field.hpp"					#include "../field/field.hpp"
#include "../globals.hpp"                  // Globals		#include "../globals.hpp"                  // Globals
#include "../hydro/hydro.hpp"					#include "../hydro/hydro.hpp"
#include "../mesh/mesh.hpp"					#include "../mesh/mesh.hpp"
#include "../parameter_input.hpp"				#include "../parameter_input.hpp"
#include "../utils/utils.hpp"					#include "../utils/utils.hpp"
#include "../scalars/scalars.hpp"				#include "../scalars/scalars.hpp"

// Configuration checking					// Configuration checking

// Static Variables						// Static Variables
// critical radius, inner radius, central gravitational param	// critical radius, inner radius, central gravitational param
// isothermal sound speed, initial phi-velocity, initial fiel	// isothermal sound speed, initial phi-velocity, initial fiel
// tilt angle, frame angular velocity				// tilt angle, frame angular velocity
static Real r_0, inv_r2, rho_0, rho_f, v_f, p_f, mu, Ye, Na, 	static Real r_0, inv_r2, rho_0, rho_f, v_f, p_f, mu, Ye, Na, 
static Real Coeff_nu_0, Coeff_nubar_0, t_L_0, t_L_1, t_coeff,	static Real Coeff_nu_0, Coeff_nubar_0, t_L_0, t_L_1, t_coeff,
static const Real float_eps = std::numeric_limits<Real>::epsi	static const Real float_eps = std::numeric_limits<Real>::epsi
static int rows; //number of rows in the IC file		static int rows; //number of rows in the IC file
static int IDT1, IDT2, IDT3, IDT4,IDT5,IDT6;			static int IDT1, IDT2, IDT3, IDT4,IDT5,IDT6;
static bool use_IC_file, set_T_at_r0;				static bool use_IC_file, set_T_at_r0;
Real fact, vfactor;						Real fact, vfactor;
static int ye_index, IYE;					static int ye_index, IYE;
static Real ye_const, ye_0;					static Real ye_const, ye_0;
Real* edens;							Real* edens;
Real* efrac;							Real* efrac;
Real* edens0;							Real* edens0;
Real* Ye0;							Real* Ye0;
// zeroQ_temp parameters:					// zeroQ_temp parameters:
static Real temp_g, dT0, tol, mod, maxc, eps;			static Real temp_g, dT0, tol, mod, maxc, eps;
// double NR parameters:					// double NR parameters:
static Real tg, yg, dtg, dyg, toldNR, moddNR, maxcdNR, epsdNR	static Real tg, yg, dtg, dyg, toldNR, moddNR, maxcdNR, epsdNR

static const double kbol      = 1.3806504*std::pow(10,-16);  	static const double kbol      = 1.3806504*std::pow(10,-16);  
static const double c         = 2.99792458*std::pow(10,10);  	static const double c         = 2.99792458*std::pow(10,10);  
static const double hbar      = 1.05457266*std::pow(10,-27); 	static const double hbar      = 1.05457266*std::pow(10,-27); 
static const double mn        = 1.6749286*std::pow(10,-24);  	static const double mn        = 1.6749286*std::pow(10,-24);  
static const double electron  = 1.6021773*std::pow(10,-6);   	static const double electron  = 1.6021773*std::pow(10,-6);   
static const double melectron = 9.1093897*std::pow(10,-28);  	static const double melectron = 9.1093897*std::pow(10,-28);  
static const double delta     = 1.2935;              // MeV	static const double delta     = 1.2935;              // MeV
static const double pi        = 3.141592653589793238462643383	static const double pi        = 3.141592653589793238462643383

// Vector Potential						// Vector Potential
static Real A3(const Real x1, const Real x2, const Real x3) {	static Real A3(const Real x1, const Real x2, const Real x3) {
  Real a3 = 0.5 * B_0 * r_0 * std::pow(r_0/x1,2) *		  Real a3 = 0.5 * B_0 * r_0 * std::pow(r_0/x1,2) *
    (std::sin(x2)*std::cos(alpha) - std::cos(x2)*std::cos(x3)	    (std::sin(x2)*std::cos(alpha) - std::cos(x2)*std::cos(x3)
  return a3;							  return a3;
}								}

static Real A2(const Real x1, const Real x2, const Real x3) {	static Real A2(const Real x1, const Real x2, const Real x3) {
  Real a2 = -0.5 * B_0 * r_0 * std::pow(r_0/x1,2) * std::sin(	  Real a2 = -0.5 * B_0 * r_0 * std::pow(r_0/x1,2) * std::sin(
  return a2;							  return a2;
}								}

static Real A1(const Real x1, const Real x2, const Real x3) {	static Real A1(const Real x1, const Real x2, const Real x3) {
  Real a1=0.0;							  Real a1=0.0;
  return a1;							  return a1;
}								}

Real fermi_approx(Real n, Real eta){				Real fermi_approx(Real n, Real eta){
  if (n==0) {							  if (n==0) {
    Real fermi = log(1.0 + exp(eta));				    Real fermi = log(1.0 + exp(eta));
    return fermi;						    return fermi;
  } else if (n==1) {						  } else if (n==1) {
    Real a  = exp(-1.0 * fabs(eta));				    Real a  = exp(-1.0 * fabs(eta));
    Real s  = std::pow(eta,2) / 2.0 + 1.6449341;		    Real s  = std::pow(eta,2) / 2.0 + 1.6449341;
    Real ff = a - std::pow(a,2) / 4.0 + std::pow(a,3) / 9.0 -	    Real ff = a - std::pow(a,2) / 4.0 + std::pow(a,3) / 9.0 -
    if (eta < 0) {						    if (eta < 0) {
        Real fermi = ff;					        Real fermi = ff;
        return fermi;						        return fermi;
    } else if (eta == 0) {					    } else if (eta == 0) {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    } else {							    } else {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    }								    }
  } else if (n==2) {						  } else if (n==2) {
    Real a  = exp(-1.0 * fabs(eta));				    Real a  = exp(-1.0 * fabs(eta));
    Real s  = std::pow(eta,3) / 3.0 + 3.2898681 * eta;		    Real s  = std::pow(eta,3) / 3.0 + 3.2898681 * eta;
    Real ff = 2.0 * (a - std::pow(a,2) / 8.0 + std::pow(a,3) 	    Real ff = 2.0 * (a - std::pow(a,2) / 8.0 + std::pow(a,3) 
    if (eta<0) {						    if (eta<0) {
        Real fermi = ff;					        Real fermi = ff;
        return fermi;						        return fermi;
    } else if (eta==0) {					    } else if (eta==0) {
        Real fermi = s + ff;					        Real fermi = s + ff;
        return fermi;						        return fermi;
    } else {							    } else {
        Real fermi = s + ff;					        Real fermi = s + ff;
        return fermi;						        return fermi;
    }								    }
  } else if (n==3) {						  } else if (n==3) {
    Real a  = exp(-1.0 * fabs(eta));				    Real a  = exp(-1.0 * fabs(eta));
    Real s  = std::pow(eta,4) / 4.0 + 4.9348022 * std::pow(et	    Real s  = std::pow(eta,4) / 4.0 + 4.9348022 * std::pow(et
    Real ff = 6.0 * (a - std::pow(a,2) / 16.0 + std::pow(a,3)	    Real ff = 6.0 * (a - std::pow(a,2) / 16.0 + std::pow(a,3)
    if (eta<0) {						    if (eta<0) {
        Real fermi = ff;					        Real fermi = ff;
        return fermi;						        return fermi;
    } else if (eta==0) {					    } else if (eta==0) {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    } else {							    } else {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    }								    }
  } else if (n==4) {						  } else if (n==4) {
    Real a  = exp(-1.0 * fabs(eta));				    Real a  = exp(-1.0 * fabs(eta));
    Real s  = std::pow(eta,5) / 5.0 + 6.5797363 * std::pow(et	    Real s  = std::pow(eta,5) / 5.0 + 6.5797363 * std::pow(et
    Real ff = 24.0 * (a - std::pow(a,2) / 32.0 + std::pow(a,3	    Real ff = 24.0 * (a - std::pow(a,2) / 32.0 + std::pow(a,3
    if (eta<0) {						    if (eta<0) {
        Real fermi = ff;					        Real fermi = ff;
        return fermi;						        return fermi;
    } else if (eta==0) {					    } else if (eta==0) {
        Real fermi = s + ff;					        Real fermi = s + ff;
        return fermi;						        return fermi;
    } else {							    } else {
        Real fermi = s + ff;					        Real fermi = s + ff;
        return fermi;						        return fermi;
    }								    }
  } else if (n==5) {						  } else if (n==5) {
    Real a  = exp(-1.0 * fabs(eta));				    Real a  = exp(-1.0 * fabs(eta));
    Real s  = std::pow(eta,6) / 6.0 + 8.2246703 * std::pow(et	    Real s  = std::pow(eta,6) / 6.0 + 8.2246703 * std::pow(et
    Real ff = 120.0 * (a - std::pow(a,2) / 64.0 + std::pow(a,	    Real ff = 120.0 * (a - std::pow(a,2) / 64.0 + std::pow(a,
    if(eta<0) {							    if(eta<0) {
        Real fermi = ff;					        Real fermi = ff;
        return fermi;						        return fermi;
    } else if(eta==0) {						    } else if(eta==0) {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    } else {							    } else {
        Real fermi = s - ff;					        Real fermi = s - ff;
        return fermi;						        return fermi;
    }								    }
  } else {							  } else {
      std::cout << " (accretion_scheckqdot_QWeos.cpp) \n n fo	      std::cout << " (accretion_scheckqdot_QWeos.cpp) \n n fo
      return 0.0;						      return 0.0;
  }								  }
}								}

static const double fermi2      = fermi_approx(2,0.0);		static const double fermi2      = fermi_approx(2,0.0);
static const double fermi4      = fermi_approx(4,0.0);		static const double fermi4      = fermi_approx(4,0.0);
static const double fermi5      = fermi_approx(5,0.0);		static const double fermi5      = fermi_approx(5,0.0);
static const double fermi3      = fermi_approx(3,0.0);		static const double fermi3      = fermi_approx(3,0.0);
static const double fermifactor = fermi2 * fermi5 / ( fermi3 	static const double fermifactor = fermi2 * fermi5 / ( fermi3 

Real QWEta(Real rho, Real T, Real Ye) {				Real QWEta(Real rho, Real T, Real Ye) {
  // Returns eta = mu_e / kbT					  // Returns eta = mu_e / kbT

  // constants							  // constants
  Real third = 1.0 / 3.0;					  Real third = 1.0 / 3.0;
  Real c = 2.99792458e10;					  Real c = 2.99792458e10;
  Real k = 1.380649e-16;					  Real k = 1.380649e-16;
  Real mn = 1.6726e-24;						  Real mn = 1.6726e-24;
  Real hbar = 6.62607015e-27/(2.0*PI);				  Real hbar = 6.62607015e-27/(2.0*PI);
  Real c3 = std::pow(k/(hbar*c),3);				  Real c3 = std::pow(k/(hbar*c),3);
  Real eta_den_const = std::pow(6.0,2.0*third);			  Real eta_den_const = std::pow(6.0,2.0*third);
  Real root3 = std::sqrt(3.0);					  Real root3 = std::sqrt(3.0);
  Real eta_den_A = std::pow(2.0,third) / eta_den_const;		  Real eta_den_A = std::pow(2.0,third) / eta_den_const;
  Real eta_den_B = 2.0*std::pow(3.0,third)/eta_den_const;	  Real eta_den_B = 2.0*std::pow(3.0,third)/eta_den_const;

  Real vol = mn/rho;						  Real vol = mn/rho;
  Real T3 = T*T*T;						  Real T3 = T*T*T;
  Real T4 = T*T3;						  Real T4 = T*T3;
  Real a = c3*std::pow(T,3)*vol*(PI/3.0);			  Real a = c3*std::pow(T,3)*vol*(PI/3.0);
  Real a2 = SQR(a);						  Real a2 = SQR(a);
  Real a4 = SQR(a2);						  Real a4 = SQR(a2);
  Real a6 = a2 * a4;						  Real a6 = a2 * a4;
  Real y2 = SQR(Ye);						  Real y2 = SQR(Ye);
  Real b = std::sqrt(4.0*a6+27.0*a4*y2);			  Real b = std::sqrt(4.0*a6+27.0*a4*y2);
  Real term = std::pow(9.0*a2*Ye+root3*b, third);		  Real term = std::pow(9.0*a2*Ye+root3*b, third);
  Real eta_by_pi = (eta_den_A)*term/a - (eta_den_B)*a/term; /	  Real eta_by_pi = (eta_den_A)*term/a - (eta_den_B)*a/term; /
  Real eta = eta_by_pi * PI;					  Real eta = eta_by_pi * PI;
  return eta;							  return eta;
}								}

// Heating/cooling function					// Heating/cooling function
Real qdotQW(Real temp, Real x, Real ye, Real time) {		Real qdotQW(Real temp, Real x, Real ye, Real time) {
  // temp is in MeV						  // temp is in MeV
  // returns heating - cooling in units of MeV s^{-1} g^{-1} 	  // returns heating - cooling in units of MeV s^{-1} g^{-1} 

  // smoothly transition from 0 at t<=t_L_0 to 1 at t>=t_L_1	  // smoothly transition from 0 at t<=t_L_0 to 1 at t>=t_L_1
  Real f = (time <= t_L_0) ? 0.0 :				  Real f = (time <= t_L_0) ? 0.0 :
           ((time >= t_L_1) ? 1.0 : SQR(std::sin((time - t_L_	           ((time >= t_L_1) ? 1.0 : SQR(std::sin((time - t_L_
  Real Coeff_nu = Coeff_nu_0 + f * dCoeff_nu;			  Real Coeff_nu = Coeff_nu_0 + f * dCoeff_nu;
  Real Coeff_nubar = Coeff_nubar_0 + f * dCoeff_nubar;		  Real Coeff_nubar = Coeff_nubar_0 + f * dCoeff_nubar;
  // Heating; multiplied 1e12 becasue r is units of 1e6 cm (s	  // Heating; multiplied 1e12 becasue r is units of 1e6 cm (s
  Real out=1e12*9.65*Na*((1.0-ye)*Coeff_nu + ye*Coeff_nubar)*	  Real out=1e12*9.65*Na*((1.0-ye)*Coeff_nu + ye*Coeff_nubar)*
  out -= 2.27*Na*std::pow(temp,6); // cooling			  out -= 2.27*Na*std::pow(temp,6); // cooling
  if(temp<Tc) {							  if(temp<Tc) {
    out *= std::exp(-0.5/temp); //alpha particles turnoff hea	    out *= std::exp(-0.5/temp); //alpha particles turnoff hea
  }								  }
//  if(temp>Th){						//  if(temp>Th){
//    out *= std::exp(-tau);					//    out *= std::exp(-tau);
//  }								//  }
  return out;							  return out;
}								}

// Ye sink/source function					// Ye sink/source function
Real YeSource(Real temp, Real ye, Real x, Real Rho) {		Real YeSource(Real temp, Real ye, Real x, Real Rho) {
  // Returns v*dYe/dr (equation 7 in Qian & Woosley 1996) in 	  // Returns v*dYe/dr (equation 7 in Qian & Woosley 1996) in 
  // temp is in MeV						  // temp is in MeV
  // Define constants						  // Define constants
  Real alpha    = 1.26; // Coupling Coefficient			  Real alpha    = 1.26; // Coupling Coefficient
  Real G_F      = std::pow(298.2*std::pow(10,3),-2.0);  // Fe	  Real G_F      = std::pow(298.2*std::pow(10,3),-2.0);  // Fe
  Real e_nue    = 1.2 * eps_nue; // Electron neutrino energy 	  Real e_nue    = 1.2 * eps_nue; // Electron neutrino energy 
  Real e_nueb   = 1.2 * eps_nueb; // Electron antineutrino en	  Real e_nueb   = 1.2 * eps_nueb; // Electron antineutrino en
  Real Delta    = 1.293; // neutron-proton mass difference in	  Real Delta    = 1.293; // neutron-proton mass difference in
  Real hbar     = 6.582119569e-22; // Planck's constant in Me	  Real hbar     = 6.582119569e-22; // Planck's constant in Me
  Real c        = 2.99792458e10; // Light speed in cm/s		  Real c        = 2.99792458e10; // Light speed in cm/s
  Real erg2MeV  = 6.24151e5; // convert erg to MeV		  Real erg2MeV  = 6.24151e5; // convert erg to MeV
  Real lum      = std::pow(10,51);				  Real lum      = std::pow(10,51);

  // Forward reaction rates					  // Forward reaction rates
  Real lambda_nue_n  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al	  Real lambda_nue_n  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al
                      *(e_nue+2.0*Delta+1.2*Delta*Delta/e_nue	                      *(e_nue+2.0*Delta+1.2*Delta*Delta/e_nue
//  Real lambda_nueb_p = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*	//  Real lambda_nueb_p = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*
//                      *(e_nueb-2.0*Delta+1.2*Delta*Delta/e_	//                      *(e_nueb-2.0*Delta+1.2*Delta*Delta/e_

  // Calculate Eta, send in T in K				  // Calculate Eta, send in T in K
  Real Eta = QWEta(Rho,temp/8.6173e-11,ye);			  Real Eta = QWEta(Rho,temp/8.6173e-11,ye);

  // Reverse reaction rates					  // Reverse reaction rates
  Real f4_0 = fermi_approx(4.0,0.0);				  Real f4_0 = fermi_approx(4.0,0.0);
  Real f4_eta = fermi_approx(4.0,Eta);				  Real f4_eta = fermi_approx(4.0,Eta);
  Real f4_negeta = fermi_approx(4.0,-1.0*Eta);			  Real f4_negeta = fermi_approx(4.0,-1.0*Eta);
  Real lambda_ele_p = 0.448*std::pow(temp,5.0)*f4_eta/f4_0; /	  Real lambda_ele_p = 0.448*std::pow(temp,5.0)*f4_eta/f4_0; /
  Real lambda_pos_n = lambda_ele_p*f4_negeta/f4_0; // s^-1 un	  Real lambda_pos_n = lambda_ele_p*f4_negeta/f4_0; // s^-1 un

//  std::cout << "T             = " << temp << " MeV" << std:	//  std::cout << "T             = " << temp << " MeV" << std:
//  std::cout << "Ye            = " << ye << std::endl;		//  std::cout << "Ye            = " << ye << std::endl;
//  std::cout << "f4_0          = " << f4_0 << std::endl;	//  std::cout << "f4_0          = " << f4_0 << std::endl;
//  std::cout << "f4_eta        = " << f4_eta << std::endl;	//  std::cout << "f4_eta        = " << f4_eta << std::endl;
//  std::cout << "f4_negeta     = " << f4_negeta << std::endl	//  std::cout << "f4_negeta     = " << f4_negeta << std::endl
//  std::cout << "lambda_nue_n  = " << lambda_nue_n << " s^-1	//  std::cout << "lambda_nue_n  = " << lambda_nue_n << " s^-1
//  std::cout << "lambda_nueb_p = " << lambda_nueb_p << " s^-	//  std::cout << "lambda_nueb_p = " << lambda_nueb_p << " s^-
//  std::cout << "lambda_ele_p  = " << lambda_ele_p << " s^-1	//  std::cout << "lambda_ele_p  = " << lambda_ele_p << " s^-1
//  std::cout << "lambda_pos_n  = " << lambda_pos_n << " s^-1	//  std::cout << "lambda_pos_n  = " << lambda_pos_n << " s^-1
//  std::cout << " " << std::endl;				//  std::cout << " " << std::endl;

  // Source - Sink						  // Source - Sink
  Real out = lambda_nue_n+lambda_pos_n; //-(lambda_nue_n+lamb	  Real out = lambda_nue_n+lambda_pos_n; //-(lambda_nue_n+lamb
  return out;							  return out;
}								}

Real YeSink(Real temp, Real ye, Real x, Real Rho) {		Real YeSink(Real temp, Real ye, Real x, Real Rho) {
  // Returns v*dYe/dr (equation 7 in Qian & Woosley 1996) in 	  // Returns v*dYe/dr (equation 7 in Qian & Woosley 1996) in 
  // temp is in MeV						  // temp is in MeV
  // Define constants						  // Define constants
  Real alpha    = 1.26; // Coupling Coefficient			  Real alpha    = 1.26; // Coupling Coefficient
  Real G_F      = std::pow(298.2*std::pow(10,3),-2.0);  // Fe	  Real G_F      = std::pow(298.2*std::pow(10,3),-2.0);  // Fe
  Real e_nue    = 1.2 * eps_nue; // Electron neutrino energy 	  Real e_nue    = 1.2 * eps_nue; // Electron neutrino energy 
  Real e_nueb   = 1.2 * eps_nueb; // Electron antineutrino en	  Real e_nueb   = 1.2 * eps_nueb; // Electron antineutrino en
  Real Delta    = 1.293; // neutron-proton mass difference in	  Real Delta    = 1.293; // neutron-proton mass difference in
  Real hbar     = 6.582119569e-22; // Planck's constant in Me	  Real hbar     = 6.582119569e-22; // Planck's constant in Me
  Real c        = 2.99792458e10; // Light speed in cm/s		  Real c        = 2.99792458e10; // Light speed in cm/s
  Real erg2MeV  = 6.24151e5; // convert erg to MeV		  Real erg2MeV  = 6.24151e5; // convert erg to MeV
  Real lum      = std::pow(10,51);				  Real lum      = std::pow(10,51);

  // Forward reaction rates					  // Forward reaction rates
  Real lambda_nue_n  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al	  Real lambda_nue_n  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al
                      *(e_nue+2.0*Delta+1.2*Delta*Delta/e_nue	                      *(e_nue+2.0*Delta+1.2*Delta*Delta/e_nue
  Real lambda_nueb_p = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al	  Real lambda_nueb_p = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al
                      *(e_nueb-2.0*Delta+1.2*Delta*Delta/e_nu	                      *(e_nueb-2.0*Delta+1.2*Delta*Delta/e_nu

  // Calculate Eta, send in T in K				  // Calculate Eta, send in T in K
  Real Eta = QWEta(Rho,temp/8.6173e-11,ye);			  Real Eta = QWEta(Rho,temp/8.6173e-11,ye);

  // Reverse reaction rates					  // Reverse reaction rates
  Real f4_0 = fermi_approx(4.0,0.0);				  Real f4_0 = fermi_approx(4.0,0.0);
  Real f4_eta = fermi_approx(4.0,Eta);				  Real f4_eta = fermi_approx(4.0,Eta);
  Real f4_negeta = fermi_approx(4.0,-1.0*Eta);			  Real f4_negeta = fermi_approx(4.0,-1.0*Eta);
  Real lambda_ele_p = 0.448*std::pow(temp,5.0)*f4_eta/f4_0; /	  Real lambda_ele_p = 0.448*std::pow(temp,5.0)*f4_eta/f4_0; /
  Real lambda_pos_n = lambda_ele_p*f4_negeta/f4_0; // s^-1 un	  Real lambda_pos_n = lambda_ele_p*f4_negeta/f4_0; // s^-1 un

//  std::cout << "T             = " << temp << " MeV" << std:	//  std::cout << "T             = " << temp << " MeV" << std:
//  std::cout << "Ye            = " << ye << std::endl;		//  std::cout << "Ye            = " << ye << std::endl;
//  std::cout << "f4_0          = " << f4_0 << std::endl;	//  std::cout << "f4_0          = " << f4_0 << std::endl;
//  std::cout << "f4_eta        = " << f4_eta << std::endl;	//  std::cout << "f4_eta        = " << f4_eta << std::endl;
//  std::cout << "f4_negeta     = " << f4_negeta << std::endl	//  std::cout << "f4_negeta     = " << f4_negeta << std::endl
//  std::cout << "lambda_nue_n  = " << lambda_nue_n << " s^-1	//  std::cout << "lambda_nue_n  = " << lambda_nue_n << " s^-1
//  std::cout << "lambda_nueb_p = " << lambda_nueb_p << " s^-	//  std::cout << "lambda_nueb_p = " << lambda_nueb_p << " s^-
//  std::cout << "lambda_ele_p  = " << lambda_ele_p << " s^-1	//  std::cout << "lambda_ele_p  = " << lambda_ele_p << " s^-1
//  std::cout << "lambda_pos_n  = " << lambda_pos_n << " s^-1	//  std::cout << "lambda_pos_n  = " << lambda_pos_n << " s^-1
//  std::cout << " " << std::endl;				//  std::cout << " " << std::endl;

  // Source - Sink						  // Source - Sink
  Real out = (lambda_nue_n+lambda_pos_n+lambda_nueb_p+lambda_	  Real out = (lambda_nue_n+lambda_pos_n+lambda_nueb_p+lambda_
  return out;							  return out;
}								}


Real Ye_f(Real temp, Real ye, Real x){				Real Ye_f(Real temp, Real ye, Real x){
  // Returns v*dYe/dr (equation 7 in Qian & Woosley 1996) in 	  // Returns v*dYe/dr (equation 7 in Qian & Woosley 1996) in 
  // temp is in MeV						  // temp is in MeV
  // Define constants						  // Define constants
  Real alpha  = 1.26; // Coupling Coefficient			  Real alpha  = 1.26; // Coupling Coefficient
  Real G_F    = std::pow(298.2*std::pow(10,3),-2.0);  // Ferm	  Real G_F    = std::pow(298.2*std::pow(10,3),-2.0);  // Ferm
  Real e_nue  = 1.2 * eps_nue; // Electron neutrino energy de	  Real e_nue  = 1.2 * eps_nue; // Electron neutrino energy de
  Real e_nueb = 1.2 * eps_nueb; // Electron antineutrino ener	  Real e_nueb = 1.2 * eps_nueb; // Electron antineutrino ener
  Real Delta  = 1.293; // neutron-proton mass difference in M	  Real Delta  = 1.293; // neutron-proton mass difference in M
  Real hbar   = 6.582119569e-22; // Planck's constant in MeV 	  Real hbar   = 6.582119569e-22; // Planck's constant in MeV 
  Real c      = 2.99792458e10; // Light speed in cm/s		  Real c      = 2.99792458e10; // Light speed in cm/s
  Real erg2MeV = 6.24151e5; // convert erg to MeV		  Real erg2MeV = 6.24151e5; // convert erg to MeV
  Real lum     = std::pow(10,51);				  Real lum     = std::pow(10,51);

  // Forward reaction rates					  // Forward reaction rates
  Real lambda_nue_n  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al	  Real lambda_nue_n  = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al
                      *(e_nue+2.0*Delta+1.2*Delta*Delta/e_nue	                      *(e_nue+2.0*Delta+1.2*Delta*Delta/e_nue
  Real lambda_nueb_p = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al	  Real lambda_nueb_p = std::pow(hbar*c,2.0)*(1.0+3.0*alpha*al
                      *(e_nueb-2.0*Delta+1.2*Delta*Delta/e_nu	                      *(e_nueb-2.0*Delta+1.2*Delta*Delta/e_nu

  // Source - Sink (look at lnue and lnueb, they should be sm	  // Source - Sink (look at lnue and lnueb, they should be sm
  Real out = (lambda_nue_n) / (lambda_nue_n + lambda_nueb_p);	  Real out = (lambda_nue_n) / (lambda_nue_n + lambda_nueb_p);
//  std::cout << "alpha = " << alpha << std::endl;		//  std::cout << "alpha = " << alpha << std::endl;
//  std::cout << "G_F   = " << G_F << " MeV^-2" << std::endl;	//  std::cout << "G_F   = " << G_F << " MeV^-2" << std::endl;
//  std::cout << "e_nue = 1.2 * eps_nue = " << e_nue << " MeV	//  std::cout << "e_nue = 1.2 * eps_nue = " << e_nue << " MeV
//  std::cout << "e_nueb = 1.2 * eps_nueb = " << e_nueb << " 	//  std::cout << "e_nueb = 1.2 * eps_nueb = " << e_nueb << " 
//  std::cout << "Delta = " << Delta << " MeV" << std::endl;	//  std::cout << "Delta = " << Delta << " MeV" << std::endl;
//  std::cout << "hbar = " << hbar << " MeV s" << std::endl;	//  std::cout << "hbar = " << hbar << " MeV s" << std::endl;
//  std::cout << "c = " << c << " cm/s" << std::endl;		//  std::cout << "c = " << c << " cm/s" << std::endl;
//  std::cout << "Lnue = " << L_nue*erg2MeV*1.0e51 << " MeV/s	//  std::cout << "Lnue = " << L_nue*erg2MeV*1.0e51 << " MeV/s
//  std::cout << "Lnueb = " << L_nueb*erg2MeV*1.0e51 << " MeV	//  std::cout << "Lnueb = " << L_nueb*erg2MeV*1.0e51 << " MeV
//  std::cout << "r_0 = " << r_0 << " cm" << std::endl;		//  std::cout << "r_0 = " << r_0 << " cm" << std::endl;
//  std::cout << "lambda_nue_n = " << lambda_nue_n << " s^-1"	//  std::cout << "lambda_nue_n = " << lambda_nue_n << " s^-1"
//  std::cout << "lambda_nueb_p = " << lambda_nueb_p << " s^-	//  std::cout << "lambda_nueb_p = " << lambda_nueb_p << " s^-
//  std::cout << "Y_e,f = " << out << std::endl;		//  std::cout << "Y_e,f = " << out << std::endl;

  return out;							  return out;
}								}

Real qdotScheck_H(Real ye, Real r) {				Real qdotScheck_H(Real ye, Real r) {
  // returns heating in units of erg s^{-1} g^{-1} units	  // returns heating in units of erg s^{-1} g^{-1} units
  const double alpha     = 1.254;				  const double alpha     = 1.254;
  const double sigmaweak = 1.76*std::pow(10,-44)*(1.0+3.0*std	  const double sigmaweak = 1.76*std::pow(10,-44)*(1.0+3.0*std
  Real Lnu               = L_nue;				  Real Lnu               = L_nue;

  Real fnu         = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0	  Real fnu         = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0
  Real sinkconst   = sigmaweak * 0.5 * (Lnu * std::pow(10,51)	  Real sinkconst   = sigmaweak * 0.5 * (Lnu * std::pow(10,51)

  // --- Absorption Term ---					  // --- Absorption Term ---
  Real q_abs  = sinkconst / mn * ((1.0 - ye) * (std::pow(eps_	  Real q_abs  = sinkconst / mn * ((1.0 - ye) * (std::pow(eps_
                                   2.0 * delta * electron * e	                                   2.0 * delta * electron * e
                                   std::pow(delta * electron,	                                   std::pow(delta * electron,
                                   3.0 * delta * electron * e	                                   3.0 * delta * electron * e
                                   3.0 * std::pow(delta * ele	                                   3.0 * std::pow(delta * ele

//  std::cout << " ";						//  std::cout << " ";
//  std::cout << "qdotScheck_H\n";				//  std::cout << "qdotScheck_H\n";
//  std::cout << "sigmaweak = " << sigmaweak << std::endl;	//  std::cout << "sigmaweak = " << sigmaweak << std::endl;
//  std::cout << "fnu       = " << fnu       << std::endl;	//  std::cout << "fnu       = " << fnu       << std::endl;
//  std::cout << "r_0       = " << r_0       << " cm" << std:	//  std::cout << "r_0       = " << r_0       << " cm" << std:
//  std::cout << "r         = " << r         << " cm" << std:	//  std::cout << "r         = " << r         << " cm" << std:
//  std::cout << "sinkconst = " << sinkconst << std::endl;	//  std::cout << "sinkconst = " << sinkconst << std::endl;
//  std::cout << "delta       = " << delta << std::endl;	//  std::cout << "delta       = " << delta << std::endl;
//  std::cout << "fermifactor = " << fermifactor << std::endl	//  std::cout << "fermifactor = " << fermifactor << std::endl
//  std::cout << "eps_nue     = " << eps_nue << std::endl;	//  std::cout << "eps_nue     = " << eps_nue << std::endl;
//  std::cout << "eps_nueb    = " << eps_nueb << std::endl;	//  std::cout << "eps_nueb    = " << eps_nueb << std::endl;
//  std::cout << "electron    = " << electron << std::endl;	//  std::cout << "electron    = " << electron << std::endl;
//  std::cout << "q_abs     = " << q_abs << std::endl;		//  std::cout << "q_abs     = " << q_abs << std::endl;
//  std::cout << "Lnu       = " << Lnu << std::endl;		//  std::cout << "Lnu       = " << Lnu << std::endl;
//  std::cout << "Ye (qdotS) = " << ye << std::endl;		//  std::cout << "Ye (qdotS) = " << ye << std::endl;
////  std::cout << "r  (qdotS) = " << r << std::endl;		////  std::cout << "r  (qdotS) = " << r << std::endl;
//  std::cout << " " << std::endl;				//  std::cout << " " << std::endl;


  return q_abs;							  return q_abs;
}								}

Real qdotScheck_C(Real temp, Real ye, Real rho, Real r) {	Real qdotScheck_C(Real temp, Real ye, Real rho, Real r) {
  // temp is in K						  // temp is in K
  // returns cooling in units of erg s^{-1} g^{-1} units	  // returns cooling in units of erg s^{-1} g^{-1} units
  const double alpha       = 1.254;				  const double alpha       = 1.254;
  const double sigmaweak   = 1.76*std::pow(10,-44)*(1.0+3.0*s	  const double sigmaweak   = 1.76*std::pow(10,-44)*(1.0+3.0*s

  Real fnu         = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0	  Real fnu         = 0.5 * (1.0 + std::pow(1.0 - std::pow(r_0
  Real Tprime      = temp * kbol / (hbar * c); // cm^-1		  Real Tprime      = temp * kbol / (hbar * c); // cm^-1
  Real Terg        = temp * kbol; // erg			  Real Terg        = temp * kbol; // erg
  Real tfact       = std::pow(27.0 * ye * rho + std::pow(3.0,	  Real tfact       = std::pow(27.0 * ye * rho + std::pow(3.0,
  Real eta_e       = std::pow(12.0 * pi,1.0/3.0) * (std::pow(	  Real eta_e       = std::pow(12.0 * pi,1.0/3.0) * (std::pow(
  Real sourceconst = sigmaweak * 0.5 * c * std::pow(Tprime,3)	  Real sourceconst = sigmaweak * 0.5 * c * std::pow(Tprime,3)

  // --- Emission Term ----					  // --- Emission Term ----
  Real q_em   = sourceconst * (ye * (std::pow(Terg,3) * fermi	  Real q_em   = sourceconst * (ye * (std::pow(Terg,3) * fermi
                              2.0 * delta * electron * std::p	                              2.0 * delta * electron * std::p
                              std::pow(delta * electron,2) * 	                              std::pow(delta * electron,2) * 
                              (1.0 - ye) * (std::pow(Terg,3) 	                              (1.0 - ye) * (std::pow(Terg,3) 
                              3.0 * std::pow(delta * electron	                              3.0 * std::pow(delta * electron

//  std::cout << " ";						//  std::cout << " ";
//  std::cout << "qdotScheck_C\n";				//  std::cout << "qdotScheck_C\n";
//  std::cout << "sigmaweak   = " << sigmaweak << "\n";		//  std::cout << "sigmaweak   = " << sigmaweak << "\n";
//  std::cout << "fnu         = " << fnu       << "\n";		//  std::cout << "fnu         = " << fnu       << "\n";
//  std::cout << "r_0       = " << r_0       << " cm" << std:	//  std::cout << "r_0       = " << r_0       << " cm" << std:
//  std::cout << "r         = " << r         << " cm" << std:	//  std::cout << "r         = " << r         << " cm" << std:
//  std::cout << "Tprime      = " << Tprime << "\n";		//  std::cout << "Tprime      = " << Tprime << "\n";
//  std::cout << "Terg        = " << Terg << "\n";		//  std::cout << "Terg        = " << Terg << "\n";
//  std::cout << "tfact       = " << tfact << "\n";		//  std::cout << "tfact       = " << tfact << "\n";
//  std::cout << "eta_e       = " << eta_e << "\n";		//  std::cout << "eta_e       = " << eta_e << "\n";
//  std::cout << "sourceconst = " << sourceconst << "\n";	//  std::cout << "sourceconst = " << sourceconst << "\n";
//  std::cout << "q_em        = " << q_em << " erg/g/s\n";	//  std::cout << "q_em        = " << q_em << " erg/g/s\n";
//  std::cout << " ";						//  std::cout << " ";

  return q_em;							  return q_em;
}								}


// Temperature at which heating=cooling				// Temperature at which heating=cooling
//inline Real zeroQ_temp(Real x, Real ye, Real time=0.0) {	//inline Real zeroQ_temp(Real x, Real ye, Real time=0.0) {
//  // smoothly transition from 0 at t<=t_L_0 to 1 at t>=t_L_	//  // smoothly transition from 0 at t<=t_L_0 to 1 at t>=t_L_
//  Real f = (time <= t_L_0) ? 0.0 :				//  Real f = (time <= t_L_0) ? 0.0 :
//           ((time >= t_L_1) ? 1.0 : SQR(std::sin((time - t_	//           ((time >= t_L_1) ? 1.0 : SQR(std::sin((time - t_
//  Real Coeff_nu = Coeff_nu_0 + f * dCoeff_nu;			//  Real Coeff_nu = Coeff_nu_0 + f * dCoeff_nu;
//  Real Coeff_nubar = Coeff_nubar_0 + f * dCoeff_nubar;	//  Real Coeff_nubar = Coeff_nubar_0 + f * dCoeff_nubar;
//  return std::pow(1e12*9.65/2.27*((1.-ye)*Coeff_nu+ye*Coeff	//  return std::pow(1e12*9.65/2.27*((1.-ye)*Coeff_nu+ye*Coeff
//                  1./6.) / 8.6173e-11;			//                  1./6.) / 8.6173e-11;
//}								//}

// Performs double NR procedure to simultaneously determine Y	// Performs double NR procedure to simultaneously determine Y
// This happens at the inner boundary, which is why x_0 = sqr	// This happens at the inner boundary, which is why x_0 = sqr
void Double_NR(Real Arr[]) {					void Double_NR(Real Arr[]) {
  Real x_0     = 0.0;						  Real x_0     = 0.0;
  Real MeV     = 8.6173e-11; // kb in MeV/K			  Real MeV     = 8.6173e-11; // kb in MeV/K
  Real T0      = tg;						  Real T0      = tg;
  Real Y0      = yg;						  Real Y0      = yg;
  for(int i=0; i<=maxcdNR; i++){				  for(int i=0; i<=maxcdNR; i++){

    // Set differential terms					    // Set differential terms
    Real deltaT0 = dtg*T0;					    Real deltaT0 = dtg*T0;
    Real deltaY0 = dyg*Y0;					    Real deltaY0 = dyg*Y0;
    Real dYe     = (Y0+deltaY0) - (Y0);				    Real dYe     = (Y0+deltaY0) - (Y0);
    Real dT      = (T0+deltaT0) - (T0);				    Real dT      = (T0+deltaT0) - (T0);

    // Set scale terms						    // Set scale terms
    Real H0         = qdotScheck_H(Y0,r_0);			    Real H0         = qdotScheck_H(Y0,r_0);
    Real H0_dT      = qdotScheck_H(Y0,r_0);			    Real H0_dT      = qdotScheck_H(Y0,r_0);
    Real H0_dY      = qdotScheck_H(Y0+deltaY0,r_0);		    Real H0_dY      = qdotScheck_H(Y0+deltaY0,r_0);
    Real Source0    = YeSource(T0*MeV,Y0,x_0,rho_0);		    Real Source0    = YeSource(T0*MeV,Y0,x_0,rho_0);
    Real Source0_dT = YeSource((T0+deltaT0)*MeV,Y0,x_0,rho_0)	    Real Source0_dT = YeSource((T0+deltaT0)*MeV,Y0,x_0,rho_0)
    Real Source0_dY = YeSource(T0*MeV,Y0+deltaY0,x_0,rho_0);	    Real Source0_dY = YeSource(T0*MeV,Y0+deltaY0,x_0,rho_0);

    // Set 'original' functions					    // Set 'original' functions
    Real qdot    = (qdotScheck_H(Y0,r_0) - qdotScheck_C(T0,Y0	    Real qdot    = (qdotScheck_H(Y0,r_0) - qdotScheck_C(T0,Y0
    Real Yedot   = (YeSource(T0*MeV,Y0,x_0,rho_0) - YeSink(T0	    Real Yedot   = (YeSource(T0*MeV,Y0,x_0,rho_0) - YeSink(T0

    // Define functions with differentials			    // Define functions with differentials
    Real dqdot_T  = (qdotScheck_H(Y0,r_0) - qdotScheck_C(T0+d	    Real dqdot_T  = (qdotScheck_H(Y0,r_0) - qdotScheck_C(T0+d
    Real dqdot_Y  = (qdotScheck_H(Y0+deltaY0,r_0) - qdotSchec	    Real dqdot_Y  = (qdotScheck_H(Y0+deltaY0,r_0) - qdotSchec
    Real dYedot_T = (YeSource((T0+deltaT0)*MeV,Y0,x_0,rho_0) 	    Real dYedot_T = (YeSource((T0+deltaT0)*MeV,Y0,x_0,rho_0) 
    Real dYedot_Y = (YeSource(T0*MeV,Y0+deltaY0,x_0,rho_0) - 	    Real dYedot_Y = (YeSource(T0*MeV,Y0+deltaY0,x_0,rho_0) - 

    // Define rescaled functions				    // Define rescaled functions
    Real f    = qdot     / H0;					    Real f    = qdot     / H0;
    Real g    = Yedot    / Source0;				    Real g    = Yedot    / Source0;
    Real f_dT = dqdot_T  / H0_dT;				    Real f_dT = dqdot_T  / H0_dT;
    Real f_dY = dqdot_Y  / H0_dY;				    Real f_dY = dqdot_Y  / H0_dY;
    Real g_dT = dYedot_T / Source0_dT;				    Real g_dT = dYedot_T / Source0_dT;
    Real g_dY = dYedot_Y / Source0_dY;				    Real g_dY = dYedot_Y / Source0_dY;

    // Define derivatives					    // Define derivatives
    Real dqdotdT = (f_dT - f) / (dT*MeV);			    Real dqdotdT = (f_dT - f) / (dT*MeV);
    Real dqdotdY = (f_dY - f) / (dYe);				    Real dqdotdY = (f_dY - f) / (dYe);
    Real dYdotdT = (g_dT - g) / (dT*MeV);			    Real dYdotdT = (g_dT - g) / (dT*MeV);
    Real dYdotdY = (g_dY - g) / (dYe);				    Real dYdotdY = (g_dY - g) / (dYe);

    if(fabs(dqdotdT) < epsdNR || fabs(dqdotdY) < epsdNR || fa	    if(fabs(dqdotdT) < epsdNR || fabs(dqdotdY) < epsdNR || fa
       std::cout << "One of the derivatives is too small! (Do	       std::cout << "One of the derivatives is too small! (Do
       Arr[0] = T0;						       Arr[0] = T0;
       Arr[1] = Y0;						       Arr[1] = Y0;
       std::cout << "dqdotdT = " << dqdotdT << std::endl;	       std::cout << "dqdotdT = " << dqdotdT << std::endl;
       std::cout << "dqdotdY = " << dqdotdY << std::endl;	       std::cout << "dqdotdY = " << dqdotdY << std::endl;
       std::cout << "dYdotdT = " << dYdotdT << std::endl;	       std::cout << "dYdotdT = " << dYdotdT << std::endl;
       std::cout << "dYdotdY = " << dYdotdY << std::endl;	       std::cout << "dYdotdY = " << dYdotdY << std::endl;
       break;							       break;
    }								    }

    /////////////////////////////////////////////////		    /////////////////////////////////////////////////
    // Solve system of equations:                  //		    // Solve system of equations:                  //
    //           A          *   x    =   b         //		    //           A          *   x    =   b         //
    //                                             //		    //                                             //
    // [ dqdotdT  dqdotdY ]   [ dT ]   [ dqdot  ]  //		    // [ dqdotdT  dqdotdY ]   [ dT ]   [ dqdot  ]  //
    // [                  ] * [    ] = [        ]  //		    // [                  ] * [    ] = [        ]  //
    // [ dYdotdT  dYdotdY ]   [ dY ]   [ dYedot ]  //		    // [ dYdotdT  dYdotdY ]   [ dY ]   [ dYedot ]  //
    //                                             //		    //                                             //
    //                          x    = A^-1 * b    //		    //                          x    = A^-1 * b    //
    /////////////////////////////////////////////////		    /////////////////////////////////////////////////

    // Invert matrix A (2x2)					    // Invert matrix A (2x2)
    Real a = dqdotdT;						    Real a = dqdotdT;
    Real b = dqdotdY;						    Real b = dqdotdY;
    Real c = dYdotdT;						    Real c = dYdotdT;
    Real d = dYdotdY;						    Real d = dYdotdY;
    Real detA = a*d - b*c;					    Real detA = a*d - b*c;
    Real Ainv00 = 1.0/detA * (d);				    Real Ainv00 = 1.0/detA * (d);
    Real Ainv01 = 1.0/detA * (-1.0 * b);			    Real Ainv01 = 1.0/detA * (-1.0 * b);
    Real Ainv10 = 1.0/detA * (-1.0 * c);			    Real Ainv10 = 1.0/detA * (-1.0 * c);
    Real Ainv11 = 1.0/detA * (a);				    Real Ainv11 = 1.0/detA * (a);
    Real delT   = (f*Ainv00 + g*Ainv01) / MeV;			    Real delT   = (f*Ainv00 + g*Ainv01) / MeV;
    Real delYe  = f*Ainv10 + g*Ainv11;				    Real delYe  = f*Ainv10 + g*Ainv11;

    // Determine new T and Ye values				    // Determine new T and Ye values
    Real T1 = T0 - delT;					    Real T1 = T0 - delT;
    Real Y1 = Y0 - delYe;					    Real Y1 = Y0 - delYe;

    // Check if T and Ye simultaneously converge. If not, con	    // Check if T and Ye simultaneously converge. If not, con
    if(fabs(T1-T0)/fabs(T1) < toldNR && fabs(Y1-Y0)/fabs(Y1) 	    if(fabs(T1-T0)/fabs(T1) < toldNR && fabs(Y1-Y0)/fabs(Y1) 
//        std::cout << "i  = " << i << std::endl;		//        std::cout << "i  = " << i << std::endl;
//        std::cout << "T0 = " << T0 << " K" << std::endl;	//        std::cout << "T0 = " << T0 << " K" << std::endl;
//        std::cout << "Y0 = " << Y0 << std::endl;		//        std::cout << "Y0 = " << Y0 << std::endl;
//        std::cout << "delT  = " << delT << " K" << std::end	//        std::cout << "delT  = " << delT << " K" << std::end
//        std::cout << "delYe = " << delYe << std::endl;	//        std::cout << "delYe = " << delYe << std::endl;
//        std::cout << "qdot  = " << qdot << "*10^21 erg/g/s"	//        std::cout << "qdot  = " << qdot << "*10^21 erg/g/s"
//        std::cout << "Yedot = " << Yedot << "*10^2 s^-1" <<	//        std::cout << "Yedot = " << Yedot << "*10^2 s^-1" <<
//        std::cout << "|T1-T0|/|T1| = " << fabs(T1-T0)/fabs(	//        std::cout << "|T1-T0|/|T1| = " << fabs(T1-T0)/fabs(
//        std::cout << "|Y1-Y0|/|Y1| = " << fabs(Y1-Y0)/fabs(	//        std::cout << "|Y1-Y0|/|Y1| = " << fabs(Y1-Y0)/fabs(
//        std::cout << " " << std::endl;			//        std::cout << " " << std::endl;
        Arr[0] = T1;						        Arr[0] = T1;
        Arr[1] = Y1;						        Arr[1] = Y1;
//        std::cout << "Success (Double_NR)" << std::endl;	//        std::cout << "Success (Double_NR)" << std::endl;
        break;							        break;
    } else {							    } else {
//      std::cout << "i            = " << i << std::endl;	//      std::cout << "i            = " << i << std::endl;
//      std::cout << "T0           = " << T0 << " K" << std::	//      std::cout << "T0           = " << T0 << " K" << std::
//      std::cout << "Y0           = " << Y0 << std::endl;	//      std::cout << "Y0           = " << Y0 << std::endl;
//      std::cout << "T1           = " << T1 << " K" << std::	//      std::cout << "T1           = " << T1 << " K" << std::
//      std::cout << "Y1           = " << Y1 << std::endl;	//      std::cout << "Y1           = " << Y1 << std::endl;
//      std::cout << "delT         = " << delT << " K" << std	//      std::cout << "delT         = " << delT << " K" << std
//      std::cout << "delYe        = " << delYe << std::endl;	//      std::cout << "delYe        = " << delYe << std::endl;
//      std::cout << "qdot         = " << qdot << "*10^21 erg	//      std::cout << "qdot         = " << qdot << "*10^21 erg
//      std::cout << "Yedot        = " << Yedot << "*10^2 s^-	//      std::cout << "Yedot        = " << Yedot << "*10^2 s^-
//      std::cout << "|T1-T0|/|T1| = " << fabs(T1-T0)/fabs(T1	//      std::cout << "|T1-T0|/|T1| = " << fabs(T1-T0)/fabs(T1
//      std::cout << "|Y1-Y0|/|Y1| = " << fabs(Y1-Y0)/fabs(Y1	//      std::cout << "|Y1-Y0|/|Y1| = " << fabs(Y1-Y0)/fabs(Y1
//      std::cout << " " << std::endl;				//      std::cout << " " << std::endl;
      T0 = T1;							      T0 = T1;
      Y0 = Y1;							      Y0 = Y1;
    }								    }
    if(i==maxcdNR) {						    if(i==maxcdNR) {
      std::cout << "Maximum iterations reached (Douuble_NR)" 	      std::cout << "Maximum iterations reached (Douuble_NR)" 
      Arr[0] = T1;						      Arr[0] = T1;
      Arr[1] = Y1;						      Arr[1] = Y1;
    }								    }
  }								  }
  return;							  return;
}								}

inline Real zeroQ_temp(Real ye, Real rho, Real r) {		inline Real zeroQ_temp(Real ye, Real rho, Real r) {
  // Perform NR on qdot to determine T at r=R_PNS such that H	  // Perform NR on qdot to determine T at r=R_PNS such that H
  Real T0 = temp_g;						  Real T0 = temp_g;
  for(int i=0; i<=maxc; i++) {					  for(int i=0; i<=maxc; i++) {
    Real DeltaT0 = dT0*T0;					    Real DeltaT0 = dT0*T0;
    Real y       = (qdotScheck_H(ye,r) - qdotScheck_C(T0,ye,r	    Real y       = (qdotScheck_H(ye,r) - qdotScheck_C(T0,ye,r
    Real yprime  = ((qdotScheck_H(ye,r) - qdotScheck_C(T0+Del	    Real yprime  = ((qdotScheck_H(ye,r) - qdotScheck_C(T0+Del
                   (qdotScheck_H(ye,r) - qdotScheck_C(T0,ye,r	                   (qdotScheck_H(ye,r) - qdotScheck_C(T0,ye,r
    if (fabs(yprime) < eps) {					    if (fabs(yprime) < eps) {
      std::cout << "(zeroQ_temp) yprime is too small!\n";	      std::cout << "(zeroQ_temp) yprime is too small!\n";
      return T0;						      return T0;
      break;							      break;
    }								    }
    Real T1 = T0 - mod * y / yprime;				    Real T1 = T0 - mod * y / yprime;
    if (fabs(T1-T0) / T1 < tol) {				    if (fabs(T1-T0) / T1 < tol) {
//      std::cout << "Root found!\n";				//      std::cout << "Root found!\n";
//      std::cout << "T1 (zeroQ_T) = " << T1 << " K" << std::	//      std::cout << "T1 (zeroQ_T) = " << T1 << " K" << std::
      return T1;						      return T1;
      break;							      break;
    }								    }
    T0 = T1;							    T0 = T1;
    if (i==maxc) {						    if (i==maxc) {
      std::cout << "(zeroQ_temp) maximum iterations reached.\	      std::cout << "(zeroQ_temp) maximum iterations reached.\
      return T0;						      return T0;
      break;							      break;
    }								    }
  }								  }
  return T0;							  return T0;
}								}

// exists_test1 from https://stackoverflow.com/a/12774387/227	// exists_test1 from https://stackoverflow.com/a/12774387/227
inline bool exists (const std::string& name) {			inline bool exists (const std::string& name) {
    if (FILE *file = fopen(name.c_str(), "r")) {		    if (FILE *file = fopen(name.c_str(), "r")) {
        fclose(file);						        fclose(file);
        return true;						        return true;
    } else {							    } else {
        return false;						        return false;
    }								    }
}								}

//Heating/cooling source term					//Heating/cooling source term
void heat_cool(MeshBlock *pmb, const Real time, const Real dt	void heat_cool(MeshBlock *pmb, const Real time, const Real dt
               const AthenaArray<Real> &prim, const AthenaArr	               const AthenaArray<Real> &prim, const AthenaArr
               const AthenaArray<Real> &bcc, AthenaArray<Real	               const AthenaArray<Real> &bcc, AthenaArray<Real
               AthenaArray<Real> &cons_scalar);			               AthenaArray<Real> &cons_scalar);

// Boundary Condition						// Boundary Condition
void InflowInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaAr	void InflowInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaAr
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh);		                   int je, int ks, int ke, int ngh);
void InflowMdotInnerX1(MeshBlock *pmb, Coordinates *pco, Athe	void InflowMdotInnerX1(MeshBlock *pmb, Coordinates *pco, Athe
                       FaceField &b, Real time, Real dt, int 	                       FaceField &b, Real time, Real dt, int 
                       int je, int ks, int ke, int ngh);	                       int je, int ks, int ke, int ngh);
void HSEInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArray	void HSEInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArray
                FaceField &b, Real time, Real dt, int is, int	                FaceField &b, Real time, Real dt, int is, int
                int je, int ks, int ke, int ngh);		                int je, int ks, int ke, int ngh);
void HSE2InnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArra	void HSE2InnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArra
                 FaceField &b, Real time, Real dt, int is, in	                 FaceField &b, Real time, Real dt, int is, in
                 int je, int ks, int ke, int ngh);		                 int je, int ks, int ke, int ngh);
void OutflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaA	void OutflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaA
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh);		                   int je, int ks, int ke, int ngh);
void InflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaAr	void InflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaAr
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh);		                   int je, int ks, int ke, int ngh);

//-----------------------------------------------------------	//-----------------------------------------------------------
//! \fn void Mesh::InitUserMeshData(ParameterInput *pin)	//! \fn void Mesh::InitUserMeshData(ParameterInput *pin)
//  \brief Function to initialize problem-specific data in me	//  \brief Function to initialize problem-specific data in me
//  to initialize variables which are global to (and therefor	//  to initialize variables which are global to (and therefor
//  functions in this file.  Called in Mesh constructor.	//  functions in this file.  Called in Mesh constructor.

void Mesh::InitUserMeshData(ParameterInput *pin) {		void Mesh::InitUserMeshData(ParameterInput *pin) {
  EnrollUserExplicitSourceFunction(heat_cool);			  EnrollUserExplicitSourceFunction(heat_cool);
  // set outer BC						  // set outer BC
  if (pin->GetString("mesh", "ox1_bc").compare("user") == 0) 	  if (pin->GetString("mesh", "ox1_bc").compare("user") == 0) 
    if (Globals::my_rank == 0)					    if (Globals::my_rank == 0)
      printf("Using USER outer BC.\n");				      printf("Using USER outer BC.\n");
    EnrollUserBoundaryFunction(BoundaryFace::outer_x1, Inflow	    EnrollUserBoundaryFunction(BoundaryFace::outer_x1, Inflow
  }								  }
  // set inner BC						  // set inner BC
  int inner_BC_choice = pin->GetOrAddInteger("problem", "inne	  int inner_BC_choice = pin->GetOrAddInteger("problem", "inne
  if (inner_BC_choice == 0) {					  if (inner_BC_choice == 0) {
    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, Inflow	    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, Inflow
  } else if (inner_BC_choice == 1) {				  } else if (inner_BC_choice == 1) {
    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, Inflow	    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, Inflow
  } else if (inner_BC_choice == 2) {				  } else if (inner_BC_choice == 2) {
    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, HSEInn	    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, HSEInn
  } else if (inner_BC_choice == 3) {				  } else if (inner_BC_choice == 3) {
    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, HSE2In	    EnrollUserBoundaryFunction(BoundaryFace::inner_x1, HSE2In
  } else {							  } else {
    std::stringstream msg;					    std::stringstream msg;
    msg << "### FATAL ERROR in Mesh::InitUserMeshData" << std	    msg << "### FATAL ERROR in Mesh::InitUserMeshData" << std
        << "Invalid inner BC choice (" << inner_BC_choice << 	        << "Invalid inner BC choice (" << inner_BC_choice << 
    ATHENA_ERROR(msg);						    ATHENA_ERROR(msg);
  }								  }
  printf("Using USER inner BC %d.\n", inner_BC_choice);		  printf("Using USER inner BC %d.\n", inner_BC_choice);

  mu = pin->GetReal("problem","GM");				  mu = pin->GetReal("problem","GM");
  rho_0 = pin->GetReal("problem","rho_0");			  rho_0 = pin->GetReal("problem","rho_0");
  rho_f = pin->GetReal("problem","rho_f");			  rho_f = pin->GetReal("problem","rho_f");
  v_f = pin->GetReal("problem","v_f");				  v_f = pin->GetReal("problem","v_f");
  p_f = pin->GetReal("problem","p_f");				  p_f = pin->GetReal("problem","p_f");
  Mdot = pin->GetReal("problem","mdot");			  Mdot = pin->GetReal("problem","mdot");
  Factor = pin->GetOrAddReal("problem","rho0factor",1.0);	  Factor = pin->GetOrAddReal("problem","rho0factor",1.0);
  r_0 = pin->GetReal("mesh","x1min");				  r_0 = pin->GetReal("mesh","x1min");
  p0 = pin->GetReal("problem","p_0");				  p0 = pin->GetReal("problem","p_0");
  inv_r2 = std::pow(r_0, -2);					  inv_r2 = std::pow(r_0, -2);
  Na = pin->GetReal("problem","Na");				  Na = pin->GetReal("problem","Na");
  Ye = pin->GetReal("problem","Ye");				  Ye = pin->GetReal("problem","Ye");
  Tc = pin->GetReal("problem","T_cutoff");			  Tc = pin->GetReal("problem","T_cutoff");
  Th = pin->GetReal("problem","T_high");			  Th = pin->GetReal("problem","T_high");
  tau = pin->GetReal("problem","tau_h");			  tau = pin->GetReal("problem","tau_h");
  B_0 = pin->GetReal("problem","B_0");				  B_0 = pin->GetReal("problem","B_0");
  B_0 = B_0/(std::pow(4.0*PI,0.5)); //convert to Lorentz-Heav	  B_0 = B_0/(std::pow(4.0*PI,0.5)); //convert to Lorentz-Heav
  alpha = pin->GetReal("problem","alpha");			  alpha = pin->GetReal("problem","alpha");
  set_T_at_r0 = pin->GetOrAddBoolean("problem", "set_T_at_r0"	  set_T_at_r0 = pin->GetOrAddBoolean("problem", "set_T_at_r0"
  // Passive scalar quantities					  // Passive scalar quantities
  ye_index = pin->GetInteger("hydro","eos_ye_index");		  ye_index = pin->GetInteger("hydro","eos_ye_index");
  IYE      = pin->GetInteger("hydro","prim_ye_index");		  IYE      = pin->GetInteger("hydro","prim_ye_index");
  ye_const = pin->GetReal("hydro","Ye_f");			  ye_const = pin->GetReal("hydro","Ye_f");
  ye_0     = pin->GetReal("hydro","Ye_0");			  ye_0     = pin->GetReal("hydro","Ye_0");
  // zeroQ parameters						  // zeroQ parameters
  temp_g = pin->GetReal("problem","Temp_guess");		  temp_g = pin->GetReal("problem","Temp_guess");
  dT0    = pin->GetReal("problem","dTemp");			  dT0    = pin->GetReal("problem","dTemp");
  tol    = pin->GetReal("problem","tolerance");			  tol    = pin->GetReal("problem","tolerance");
  mod    = pin->GetReal("problem","modifier");			  mod    = pin->GetReal("problem","modifier");
  maxc   = pin->GetReal("problem","maxcount");			  maxc   = pin->GetReal("problem","maxcount");
  eps    = pin->GetReal("problem","epsilon");			  eps    = pin->GetReal("problem","epsilon");
  // Double NR parameters					  // Double NR parameters
  tg = pin->GetReal("problem","Tg_doubleNR");			  tg = pin->GetReal("problem","Tg_doubleNR");
  yg = pin->GetReal("problem","Yeg_doubleNR");			  yg = pin->GetReal("problem","Yeg_doubleNR");
  dtg = pin->GetReal("problem","DeltaTg_doubleNR");		  dtg = pin->GetReal("problem","DeltaTg_doubleNR");
  dyg = pin->GetReal("problem","DeltaYeg_doubleNR");		  dyg = pin->GetReal("problem","DeltaYeg_doubleNR");
  toldNR = pin->GetReal("problem","Tolerance_doubleNR");	  toldNR = pin->GetReal("problem","Tolerance_doubleNR");
  moddNR = pin->GetReal("problem","Modifier_doubleNR");		  moddNR = pin->GetReal("problem","Modifier_doubleNR");
  maxcdNR = pin->GetReal("problem","MaxC_doubleNR");		  maxcdNR = pin->GetReal("problem","MaxC_doubleNR");
  epsdNR = pin->GetReal("problem","eps_doubleNR");		  epsdNR = pin->GetReal("problem","eps_doubleNR");
  qdfactor = pin->GetReal("problem","qdot_factor");		  qdfactor = pin->GetReal("problem","qdot_factor");
  ydfactor = pin->GetReal("problem","ydot_factor");		  ydfactor = pin->GetReal("problem","ydot_factor");
  // final limonosity/energies					  // final limonosity/energies
  Real L_nu = pin->GetReal("problem","L_nu");			  Real L_nu = pin->GetReal("problem","L_nu");
  Real L_nubar = pin->GetReal("problem","L_nubar");		  Real L_nubar = pin->GetReal("problem","L_nubar");
  L_nue = pin->GetReal("problem","L_nu");			  L_nue = pin->GetReal("problem","L_nu");
  L_nueb = pin->GetReal("problem","L_nubar");			  L_nueb = pin->GetReal("problem","L_nubar");
  Real eps_nu = pin->GetReal("problem","eps_nu");		  Real eps_nu = pin->GetReal("problem","eps_nu");
  Real eps_nubar = pin->GetReal("problem","eps_nubar");		  Real eps_nubar = pin->GetReal("problem","eps_nubar");
  eps_nue = pin->GetReal("problem","eps_nu");			  eps_nue = pin->GetReal("problem","eps_nu");
  eps_nueb = pin->GetReal("problem","eps_nubar");		  eps_nueb = pin->GetReal("problem","eps_nubar");
  Coeff_nu_0 = L_nu * SQR(eps_nu);				  Coeff_nu_0 = L_nu * SQR(eps_nu);
  Coeff_nubar_0 = L_nubar * SQR(eps_nubar);			  Coeff_nubar_0 = L_nubar * SQR(eps_nubar);
  // finial limonosity/energies					  // finial limonosity/energies
  L_nu = pin->GetOrAddReal("problem","L_nu_f",L_nu);		  L_nu = pin->GetOrAddReal("problem","L_nu_f",L_nu);
  L_nubar = pin->GetOrAddReal("problem","L_nubar_f",L_nubar);	  L_nubar = pin->GetOrAddReal("problem","L_nubar_f",L_nubar);
  eps_nu = pin->GetOrAddReal("problem","eps_nu_f",eps_nu);	  eps_nu = pin->GetOrAddReal("problem","eps_nu_f",eps_nu);
  eps_nubar = pin->GetOrAddReal("problem","eps_nubar_f",eps_n	  eps_nubar = pin->GetOrAddReal("problem","eps_nubar_f",eps_n
  Real coeff = L_nu * SQR(eps_nu);				  Real coeff = L_nu * SQR(eps_nu);
  dCoeff_nu = coeff - Coeff_nu_0;				  dCoeff_nu = coeff - Coeff_nu_0;
  coeff = L_nubar * SQR(eps_nubar);				  coeff = L_nubar * SQR(eps_nubar);
  dCoeff_nubar = coeff - Coeff_nubar_0;				  dCoeff_nubar = coeff - Coeff_nubar_0;
  Real inf = std::numeric_limits<Real>::infinity();		  Real inf = std::numeric_limits<Real>::infinity();
  t_L_0 = pin->GetOrAddReal("problem","l_transition_start",in	  t_L_0 = pin->GetOrAddReal("problem","l_transition_start",in
  t_L_1 = pin->GetOrAddReal("problem","l_transition_end",inf)	  t_L_1 = pin->GetOrAddReal("problem","l_transition_end",inf)
  if (t_L_1 < inf && t_L_1 <= t_L_0) {				  if (t_L_1 < inf && t_L_1 <= t_L_0) {
    std::stringstream msg;					    std::stringstream msg;
    msg << "### FATAL ERROR in Mesh::InitUserMeshData" << std	    msg << "### FATAL ERROR in Mesh::InitUserMeshData" << std
        << "l_transition_end <= l_transition_start" << std::e	        << "l_transition_end <= l_transition_start" << std::e
    ATHENA_ERROR(msg);						    ATHENA_ERROR(msg);
  }								  }
  t_coeff = 0.5 * PI / (t_L_1 - t_L_0);				  t_coeff = 0.5 * PI / (t_L_1 - t_L_0);
  T_floor = pin->GetOrAddReal("hydro", "T_floor", float_eps);	  T_floor = pin->GetOrAddReal("hydro", "T_floor", float_eps);

  // Parse IC choice						  // Parse IC choice
  std::string file;						  std::string file;
  bool has_file = pin->DoesParameterExist("problem", "file");	  bool has_file = pin->DoesParameterExist("problem", "file");
  if (has_file) {						  if (has_file) {
    file = pin->GetString("problem", "file");			    file = pin->GetString("problem", "file");
  }								  }
  bool use_IC_specified = pin->DoesParameterExist("problem", 	  bool use_IC_specified = pin->DoesParameterExist("problem", 
  use_IC_file = pin->GetOrAddBoolean("problem", "use_IC_file"	  use_IC_file = pin->GetOrAddBoolean("problem", "use_IC_file"

  if (use_IC_specified && use_IC_file) {			  if (use_IC_specified && use_IC_file) {
    if (!has_file) {						    if (!has_file) {
      std::stringstream msg;					      std::stringstream msg;
      msg << "### FATAL ERROR in Mesh::InitUserMeshData" << s	      msg << "### FATAL ERROR in Mesh::InitUserMeshData" << s
          << "No IC file specified in input file." << std::en	          << "No IC file specified in input file." << std::en
      ATHENA_ERROR(msg);					      ATHENA_ERROR(msg);
    }								    }
    if (!exists(file)) {					    if (!exists(file)) {
      std::stringstream msg;					      std::stringstream msg;
      msg << "### FATAL ERROR in Mesh::InitUserMeshData" << s	      msg << "### FATAL ERROR in Mesh::InitUserMeshData" << s
          << "Specified IC file " << file << "does not exits.	          << "Specified IC file " << file << "does not exits.
      ATHENA_ERROR(msg);					      ATHENA_ERROR(msg);
    }								    }
  }								  }

  if (has_file) {						  if (has_file) {
    if (!exists(file)) {					    if (!exists(file)) {
      use_IC_file = false;					      use_IC_file = false;
      if (Globals::my_rank == 0) {				      if (Globals::my_rank == 0) {
        std::cout << "Unable to locate IC file " << file << "	        std::cout << "Unable to locate IC file " << file << "
                  << std::endl;					                  << std::endl;
      }								      }
    }								    }
  }								  }

  // Read ICs from data file					  // Read ICs from data file
  if (use_IC_file) {						  if (use_IC_file) {
    rows = pin->GetInteger("problem", "rows");			    rows = pin->GetInteger("problem", "rows");
    int cols = pin->GetInteger("problem", "cols");		    int cols = pin->GetInteger("problem", "cols");
    int col_rho = pin->GetInteger("problem", "col_rho");	    int col_rho = pin->GetInteger("problem", "col_rho");
    int col_v = pin->GetInteger("problem", "col_v");		    int col_v = pin->GetInteger("problem", "col_v");
    int col_T = pin->GetInteger("problem", "col_T");		    int col_T = pin->GetInteger("problem", "col_T");
    int col_Ye = pin->GetInteger("problem", "col_Ye");		    int col_Ye = pin->GetInteger("problem", "col_Ye");

    // Prepare arrays to hold profile				    // Prepare arrays to hold profile
    AllocateRealUserMeshDataField(7);				    AllocateRealUserMeshDataField(7);
    ruser_mesh_data[0].NewAthenaArray(rows);			    ruser_mesh_data[0].NewAthenaArray(rows);
    ruser_mesh_data[1].NewAthenaArray(rows);			    ruser_mesh_data[1].NewAthenaArray(rows);
    ruser_mesh_data[2].NewAthenaArray(rows);			    ruser_mesh_data[2].NewAthenaArray(rows);
    ruser_mesh_data[3].NewAthenaArray(rows);			    ruser_mesh_data[3].NewAthenaArray(rows);
    ruser_mesh_data[4].NewAthenaArray(rows);			    ruser_mesh_data[4].NewAthenaArray(rows);
    AthenaArray<Real>& r_in{ruser_mesh_data[0]};		    AthenaArray<Real>& r_in{ruser_mesh_data[0]};
    AthenaArray<Real>& rho_in{ruser_mesh_data[1]};		    AthenaArray<Real>& rho_in{ruser_mesh_data[1]};
    AthenaArray<Real>& v_in{ruser_mesh_data[2]};		    AthenaArray<Real>& v_in{ruser_mesh_data[2]};
    AthenaArray<Real>& T_in{ruser_mesh_data[3]};		    AthenaArray<Real>& T_in{ruser_mesh_data[3]};
    AthenaArray<Real>& Ye_in{ruser_mesh_data[4]};		    AthenaArray<Real>& Ye_in{ruser_mesh_data[4]};

    if (Globals::my_rank == 0)					    if (Globals::my_rank == 0)
      std::cout<< "Using IC file: " << file << "\n";		      std::cout<< "Using IC file: " << file << "\n";
    std::string line;						    std::string line;
    std::ifstream stream;					    std::ifstream stream;

    stream.open(file);						    stream.open(file);
    Real s_vals[cols];						    Real s_vals[cols];

    for (int n = 0; n < rows; ++n) {				    for (int n = 0; n < rows; ++n) {
      std::getline(stream, line);				      std::getline(stream, line);
      std::string word;						      std::string word;
      std::stringstream iss(line);				      std::stringstream iss(line);
      int m=0;							      int m=0;
      while (iss >> word) {					      while (iss >> word) {
        s_vals[m]=std::stof(word);				        s_vals[m]=std::stof(word);
        m=m+1;							        m=m+1;
      }								      }
      //std::cout<<line;					      //std::cout<<line;
      r_in(n)=s_vals[0];					      r_in(n)=s_vals[0];
      rho_in(n) = s_vals[col_rho+1];				      rho_in(n) = s_vals[col_rho+1];
      v_in(n) = s_vals[col_v+1];				      v_in(n) = s_vals[col_v+1];
      T_in(n) = s_vals[col_T+1];				      T_in(n) = s_vals[col_T+1];
      Ye_in(n) = s_vals[col_Ye+1];				      Ye_in(n) = s_vals[col_Ye+1];
      if (Globals::my_rank == 0) {				      if (Globals::my_rank == 0) {
       // std::cout<<r_in(n)<<" ,"<<rho_in(n)<<" , "<<v_in(n)	       // std::cout<<r_in(n)<<" ,"<<rho_in(n)<<" , "<<v_in(n)
       // std::cout<<"\n";					       // std::cout<<"\n";
      }								      }
    }								    }

  }								  }
  return;							  return;
}								}

void MeshBlock::InitUserMeshBlockData(ParameterInput *pin) {	void MeshBlock::InitUserMeshBlockData(ParameterInput *pin) {
  // Calculate equilibrium T and Ye such that qdot=0 and vdYe	  // Calculate equilibrium T and Ye such that qdot=0 and vdYe
  // Since these calculations don't vary in radius, I can per	  // Since these calculations don't vary in radius, I can per
  Real Arr[2];							  Real Arr[2];
  Double_NR(Arr);						  Double_NR(Arr);
  T_eq = Arr[0];						  T_eq = Arr[0];
  Ye_eq = Arr[1];						  Ye_eq = Arr[1];
  Real* Ye_eq_ptr = &Ye_eq;					  Real* Ye_eq_ptr = &Ye_eq;
  p_0 = peos->PresFromRhoT(rho_0, T_eq, Ye_eq_ptr);		  p_0 = peos->PresFromRhoT(rho_0, T_eq, Ye_eq_ptr);
  std::cout << "T_eq = " << T_eq << " K" << std::endl;		  std::cout << "T_eq = " << T_eq << " K" << std::endl;
  std::cout << "Ye_eq = " << Ye_eq << std::endl;		  std::cout << "Ye_eq = " << Ye_eq << std::endl;
  std::cout << "p_0 = " << p_0 << " erg/cm^3" << std::endl;	  std::cout << "p_0 = " << p_0 << " erg/cm^3" << std::endl;
  dpdd_0 = peos->AsqFromRhoP(rho_0, p_0, Ye_eq_ptr);		  dpdd_0 = peos->AsqFromRhoP(rho_0, p_0, Ye_eq_ptr);

  if (COMP_DT) {						  if (COMP_DT) {
      int i = 0;						      int i = 0;

      IDT1 = i;							      IDT1 = i;
      IDT2 = i + 1;						      IDT2 = i + 1;
      IDT3 = i + 2;						      IDT3 = i + 2;
      IDT4 = i + 3;						      IDT4 = i + 3;
      IDT5 = i + 4;						      IDT5 = i + 4;
      IDT6 = i + 5;						      IDT6 = i + 5;
      i += 6;							      i += 6;

      AllocateUserOutputVariables(i);				      AllocateUserOutputVariables(i);

      SetUserOutputVariableName(IDT1, "dt1");			      SetUserOutputVariableName(IDT1, "dt1");
      SetUserOutputVariableName(IDT2, "dt2");			      SetUserOutputVariableName(IDT2, "dt2");
      SetUserOutputVariableName(IDT3, "dt3");			      SetUserOutputVariableName(IDT3, "dt3");
      SetUserOutputVariableName(IDT4, "x1flux");		      SetUserOutputVariableName(IDT4, "x1flux");
      SetUserOutputVariableName(IDT5, "dflx_vol");		      SetUserOutputVariableName(IDT5, "dflx_vol");
      SetUserOutputVariableName(IDT6, "coord_src1");		      SetUserOutputVariableName(IDT6, "coord_src1");
  }								  }
}								}

//-----------------------------------------------------------	//-----------------------------------------------------------
//! \fn void MeshBlock::ProblemGenerator(ParameterInput *pin)	//! \fn void MeshBlock::ProblemGenerator(ParameterInput *pin)
//  \brief Problem Generator for the Parker wind		//  \brief Problem Generator for the Parker wind

void MeshBlock::ProblemGenerator(ParameterInput *pin) {		void MeshBlock::ProblemGenerator(ParameterInput *pin) {
  // if root processor and zeroth block				  // if root processor and zeroth block
 // if ((Globals::my_rank == 0) && (lid == 0)){			 // if ((Globals::my_rank == 0) && (lid == 0)){
 //   std::cout<<"ENTER PGEN NOW NOW, finally right\n";		 //   std::cout<<"ENTER PGEN NOW NOW, finally right\n";
 // }								 // }

  if (use_IC_file) {						  if (use_IC_file) {
    // define references for MeshBlock::ProblemGenerator	    // define references for MeshBlock::ProblemGenerator
    AthenaArray<Real>& r_in{pmy_mesh->ruser_mesh_data[0]};	    AthenaArray<Real>& r_in{pmy_mesh->ruser_mesh_data[0]};
    AthenaArray<Real>& rho_in{pmy_mesh->ruser_mesh_data[1]};	    AthenaArray<Real>& rho_in{pmy_mesh->ruser_mesh_data[1]};
    AthenaArray<Real>& v_in{pmy_mesh->ruser_mesh_data[2]};	    AthenaArray<Real>& v_in{pmy_mesh->ruser_mesh_data[2]};
    AthenaArray<Real>& T_in{pmy_mesh->ruser_mesh_data[3]};	    AthenaArray<Real>& T_in{pmy_mesh->ruser_mesh_data[3]};
    AthenaArray<Real>& Ye_in{pmy_mesh->ruser_mesh_data[4]};	    AthenaArray<Real>& Ye_in{pmy_mesh->ruser_mesh_data[4]};


    for (int k=ks; k<=ke; k++) {				    for (int k=ks; k<=ke; k++) {
      // Real phi = pcoord->x3v(k);				      // Real phi = pcoord->x3v(k);
      for (int j=js; j<=je; j++) {				      for (int j=js; j<=je; j++) {
        Real theta = pcoord->x2v(j);				        Real theta = pcoord->x2v(j);
     //	std::cout<< "x2v(j) = " << pcoord->x2v(j) << "\n";	     //	std::cout<< "x2v(j) = " << pcoord->x2v(j) << "\n";
        for (int i=is; i<=ie; i++) {				        for (int i=is; i<=ie; i++) {
          Real r = pcoord->x1v(i);				          Real r = pcoord->x1v(i);
          Real r0 = 5e6;					          Real r0 = 5e6;
          Real rho, v, temp, ye;				          Real rho, v, temp, ye;

          int index=0;						          int index=0;
          Real min=1e15;					          Real min=1e15;
          Real diff;						          Real diff;

          for (int f=0; f<rows; f++) {				          for (int f=0; f<rows; f++) {
            diff=r-r_in(f);					            diff=r-r_in(f);
            if(diff>=0.0) {					            if(diff>=0.0) {
              if(diff<min) {					              if(diff<min) {
                min=diff;					                min=diff;
                index=f;					                index=f;
              }							              }
            }							            }
          }							          }
          //linear interpolation when r values in ICs and sim	          //linear interpolation when r values in ICs and sim
          if(r<2.1e6 and rho_0>1.5e12) {			          if(r<2.1e6 and rho_0>1.5e12) {
            Real qp= std::pow(r_0/r,20.0);			            Real qp= std::pow(r_0/r,20.0);
            rho=rho_0*qp;					            rho=rho_0*qp;
            // Real mdot= 4.0*3.14*r*r*rho_in(index)*v_in(ind	            // Real mdot= 4.0*3.14*r*r*rho_in(index)*v_in(ind
            v=(4.34e-4)*2e33/(4.0*3.14*r*r*rho);		            v=(4.34e-4)*2e33/(4.0*3.14*r*r*rho);
          }							          }
          else {						          else {
            rho=rho_in(index)+(r-r_in(index))*(rho_in(index+1	            rho=rho_in(index)+(r-r_in(index))*(rho_in(index+1
                    /(r_in(index+1)-r_in(index));		                    /(r_in(index+1)-r_in(index));
            v=v_in(index)+(r-r_in(index))*(v_in(index+1)-v_in	            v=v_in(index)+(r-r_in(index))*(v_in(index+1)-v_in
                  /(r_in(index+1)-r_in(index));			                  /(r_in(index+1)-r_in(index));
          }							          }

          temp=T_in(index)+(r-r_in(index))*(T_in(index+1)-T_i	          temp=T_in(index)+(r-r_in(index))*(T_in(index+1)-T_i
               /(r_in(index+1)-r_in(index));			               /(r_in(index+1)-r_in(index));
          ye=Ye_in(index)+(r-r_in(index))*(Ye_in(index+1)-Ye_	          ye=Ye_in(index)+(r-r_in(index))*(Ye_in(index+1)-Ye_
               /(r_in(index+1)-r_in(index));			               /(r_in(index+1)-r_in(index));

          phydro->u(IDN,k,j,i) = rho;				          phydro->u(IDN,k,j,i) = rho;
          phydro->u(IM1,k,j,i) = v * rho;			          phydro->u(IM1,k,j,i) = v * rho;
          phydro->u(IM2,k,j,i) = 0.0;				          phydro->u(IM2,k,j,i) = 0.0;
          phydro->u(IM3,k,j,i) = 0.0;				          phydro->u(IM3,k,j,i) = 0.0;
          pscalars->s(ye_index,k,j,i) = ye*rho;			          pscalars->s(ye_index,k,j,i) = ye*rho;
          pscalars->r(ye_index,k,j,i) = ye;			          pscalars->r(ye_index,k,j,i) = ye;
          edens = &pscalars->s(ye_index,k,j,i);			          edens = &pscalars->s(ye_index,k,j,i);
          efrac = &pscalars->r(ye_index,k,j,i);			          efrac = &pscalars->r(ye_index,k,j,i);
          if (NON_BAROTROPIC_EOS) {				          if (NON_BAROTROPIC_EOS) {
            if (GENERAL_EOS) {					            if (GENERAL_EOS) {
              Real pressure = peos->PresFromRhoT(rho, temp, e	              Real pressure = peos->PresFromRhoT(rho, temp, e
              phydro->u(IEN,k,j,i) = peos->EgasFromRhoP(rho, 	              phydro->u(IEN,k,j,i) = peos->EgasFromRhoP(rho, 
            }							            }
            phydro->u(IEN,k,j,i)+=0.5*(SQR(phydro->u(IM1,k,j,	            phydro->u(IEN,k,j,i)+=0.5*(SQR(phydro->u(IM1,k,j,
                                       +SQR(phydro->u(IM3,k,j	                                       +SQR(phydro->u(IM3,k,j
          }							          }
        }							        }
      }								      }
    }								    }
  }								  }

  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    // if root processor and zeroth block			    // if root processor and zeroth block
    if ((Globals::my_rank == 0) && (lid == 0)){			    if ((Globals::my_rank == 0) && (lid == 0)){
      std::cout<<"YES ENTER B field\n";				      std::cout<<"YES ENTER B field\n";
    }								    }
    AthenaArray<Real> a1,a2,a3;					    AthenaArray<Real> a1,a2,a3;
    int nx1 = (ie-is)+1 + 2*(NGHOST);				    int nx1 = (ie-is)+1 + 2*(NGHOST);
    int nx2 = (je-js)+1 + 2*(NGHOST);				    int nx2 = (je-js)+1 + 2*(NGHOST);
    int nx3 = (ke-ks)+1 + 2*(NGHOST);				    int nx3 = (ke-ks)+1 + 2*(NGHOST);
    a1.NewAthenaArray(nx3,nx2,nx1);				    a1.NewAthenaArray(nx3,nx2,nx1);
    a2.NewAthenaArray(nx3,nx2,nx1);				    a2.NewAthenaArray(nx3,nx2,nx1);
    a3.NewAthenaArray(nx3,nx2,nx1);				    a3.NewAthenaArray(nx3,nx2,nx1);

    for (int k=ks; k<=ke+1; k++) {				    for (int k=ks; k<=ke+1; k++) {
      for (int j=js; j<=je+1; j++) {				      for (int j=js; j<=je+1; j++) {
        for (int i=is; i<=ie+1; i++) {				        for (int i=is; i<=ie+1; i++) {
          a1(k,j,i) = A1(pcoord->x1v(i), pcoord->x2f(j), pcoo	          a1(k,j,i) = A1(pcoord->x1v(i), pcoord->x2f(j), pcoo
          a2(k,j,i) = A2(pcoord->x1f(i), pcoord->x2v(j), pcoo	          a2(k,j,i) = A2(pcoord->x1f(i), pcoord->x2v(j), pcoo
          a3(k,j,i) = A3(pcoord->x1f(i), pcoord->x2f(j), pcoo	          a3(k,j,i) = A3(pcoord->x1f(i), pcoord->x2f(j), pcoo
        }							        }
      }								      }
    }								    }

    // Initialize interface fields				    // Initialize interface fields
    AthenaArray<Real> area,len,len_p1;				    AthenaArray<Real> area,len,len_p1;
    area.NewAthenaArray(nx1);					    area.NewAthenaArray(nx1);
    len.NewAthenaArray(nx1);					    len.NewAthenaArray(nx1);
    len_p1.NewAthenaArray(nx1);					    len_p1.NewAthenaArray(nx1);

    // for 1,2,3-D						    // for 1,2,3-D
    int jl=js; int ju=je+1;					    int jl=js; int ju=je+1;
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      // reset loop limits for polar boundary			      // reset loop limits for polar boundary

      if ((pbval->block_bcs[BoundaryFace::inner_x2] == Bounda	      if ((pbval->block_bcs[BoundaryFace::inner_x2] == Bounda
        (pbval->block_bcs[BoundaryFace::inner_x2] == Boundary	        (pbval->block_bcs[BoundaryFace::inner_x2] == Boundary
        jl=js+1;						        jl=js+1;
      if ((pbval->block_bcs[BoundaryFace::outer_x2] == Bounda	      if ((pbval->block_bcs[BoundaryFace::outer_x2] == Bounda
        (pbval->block_bcs[BoundaryFace::outer_x2] == Boundary	        (pbval->block_bcs[BoundaryFace::outer_x2] == Boundary
        ju=je;							        ju=je;
      for (int j=jl; j<=ju; ++j) {				      for (int j=jl; j<=ju; ++j) {
        pcoord->Face2Area(k,j,is,ie,area);			        pcoord->Face2Area(k,j,is,ie,area);
        pcoord->Edge3Length(k,j,is,ie+1,len);			        pcoord->Edge3Length(k,j,is,ie+1,len);
        for (int i=is; i<=ie; ++i) {				        for (int i=is; i<=ie; ++i) {
          pfield->b.x2f(k,j,i) = -1.0*(len(i+1)*a3(k,j,i+1) -	          pfield->b.x2f(k,j,i) = -1.0*(len(i+1)*a3(k,j,i+1) -
        }							        }
      }								      }
    }								    }
    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
        pcoord->Face3Area(k,j,is,ie,area);			        pcoord->Face3Area(k,j,is,ie,area);
        pcoord->Edge2Length(k,j,is,ie+1,len);			        pcoord->Edge2Length(k,j,is,ie+1,len);
        for (int i=is; i<=ie; ++i) {				        for (int i=is; i<=ie; ++i) {
          pfield->b.x3f(k,j,i) = (len(i+1)*a2(k,j,i+1) - len(	          pfield->b.x3f(k,j,i) = (len(i+1)*a2(k,j,i+1) - len(
        }							        }
      }								      }
    }								    }

    // for 2D and 3D						    // for 2D and 3D
    if (block_size.nx2 > 1) {					    if (block_size.nx2 > 1) {
      for (int k=ks; k<=ke; ++k) {				      for (int k=ks; k<=ke; ++k) {
        for (int j=js; j<=je; ++j) {				        for (int j=js; j<=je; ++j) {
          pcoord->Face1Area(k,j,is,ie+1,area);			          pcoord->Face1Area(k,j,is,ie+1,area);
          pcoord->Edge3Length(k,j  ,is,ie+1,len);		          pcoord->Edge3Length(k,j  ,is,ie+1,len);
          pcoord->Edge3Length(k,j+1,is,ie+1,len_p1);		          pcoord->Edge3Length(k,j+1,is,ie+1,len_p1);
          for (int i=is; i<=ie+1; ++i) {			          for (int i=is; i<=ie+1; ++i) {
            pfield->b.x1f(k,j,i) = (len_p1(i)*a3(k,j+1,i) - l	            pfield->b.x1f(k,j,i) = (len_p1(i)*a3(k,j+1,i) - l
          }							          }
        }							        }
      }								      }
      for (int k=ks; k<=ke+1; ++k) {				      for (int k=ks; k<=ke+1; ++k) {
        for (int j=js; j<=je; ++j) {				        for (int j=js; j<=je; ++j) {
          pcoord->Face3Area(k,j,is,ie,area);			          pcoord->Face3Area(k,j,is,ie,area);
          pcoord->Edge1Length(k,j  ,is,ie,len);			          pcoord->Edge1Length(k,j  ,is,ie,len);
          pcoord->Edge1Length(k,j+1,is,ie,len_p1);		          pcoord->Edge1Length(k,j+1,is,ie,len_p1);
          for (int i=is; i<=ie; ++i) {				          for (int i=is; i<=ie; ++i) {
            pfield->b.x3f(k,j,i) -= (len_p1(i)*a1(k,j+1,i) - 	            pfield->b.x3f(k,j,i) -= (len_p1(i)*a1(k,j+1,i) - 
          }							          }
        }							        }
      }								      }
    }								    }
    // for 3D only						    // for 3D only
    if (block_size.nx3 > 1) {					    if (block_size.nx3 > 1) {
      for (int k=ks; k<=ke; ++k) {				      for (int k=ks; k<=ke; ++k) {
        for (int j=js; j<=je; ++j) {				        for (int j=js; j<=je; ++j) {
          pcoord->Face1Area(k,j,is,ie+1,area);			          pcoord->Face1Area(k,j,is,ie+1,area);
          pcoord->Edge2Length(k  ,j,is,ie+1,len);		          pcoord->Edge2Length(k  ,j,is,ie+1,len);
          pcoord->Edge2Length(k+1,j,is,ie+1,len_p1);		          pcoord->Edge2Length(k+1,j,is,ie+1,len_p1);
          for (int i=is; i<=ie+1; ++i) {			          for (int i=is; i<=ie+1; ++i) {
            pfield->b.x1f(k,j,i) -= (len_p1(i)*a2(k+1,j,i) - 	            pfield->b.x1f(k,j,i) -= (len_p1(i)*a2(k+1,j,i) - 
          }							          }
        }							        }
      }								      }
      for (int k=ks; k<=ke; ++k) {				      for (int k=ks; k<=ke; ++k) {
        // reset loop limits for polar boundary			        // reset loop limits for polar boundary
        int jl=js; int ju=je+1;					        int jl=js; int ju=je+1;
        if ((pbval->block_bcs[BoundaryFace::inner_x2] == Boun	        if ((pbval->block_bcs[BoundaryFace::inner_x2] == Boun
          (pbval->block_bcs[BoundaryFace::inner_x2] == Bounda	          (pbval->block_bcs[BoundaryFace::inner_x2] == Bounda
          jl=js+1;						          jl=js+1;
        if ((pbval->block_bcs[BoundaryFace::outer_x2] == Boun	        if ((pbval->block_bcs[BoundaryFace::outer_x2] == Boun
          (pbval->block_bcs[BoundaryFace::outer_x2] == Bounda	          (pbval->block_bcs[BoundaryFace::outer_x2] == Bounda
          ju=je;						          ju=je;
        for (int j=jl; j<=ju; ++j) {				        for (int j=jl; j<=ju; ++j) {
          pcoord->Face2Area(k,j,is,ie,area);			          pcoord->Face2Area(k,j,is,ie,area);
          pcoord->Edge1Length(k  ,j,is,ie,len);			          pcoord->Edge1Length(k  ,j,is,ie,len);
          pcoord->Edge1Length(k+1,j,is,ie,len_p1);		          pcoord->Edge1Length(k+1,j,is,ie,len_p1);
          for (int i=is; i<=ie; ++i) {				          for (int i=is; i<=ie; ++i) {
            pfield->b.x2f(k,j,i) += (len_p1(i)*a1(k+1,j,i) - 	            pfield->b.x2f(k,j,i) += (len_p1(i)*a1(k+1,j,i) - 
          }							          }
        }							        }
      }								      }
    }								    }
    // Calculate cell-centered magnetic field			    // Calculate cell-centered magnetic field
    AthenaArray<Real> bb;					    AthenaArray<Real> bb;
    bb.NewAthenaArray(3, ke+1, je+1, ie+NGHOST+1);		    bb.NewAthenaArray(3, ke+1, je+1, ie+NGHOST+1);
    pfield->CalculateCellCenteredField(pfield->b, bb, pcoord,	    pfield->CalculateCellCenteredField(pfield->b, bb, pcoord,
                                       je, ks, ke);		                                       je, ks, ke);

    for (int k=ks; k<=ke; k++) {				    for (int k=ks; k<=ke; k++) {
      for (int j=js; j<=je; j++) {				      for (int j=js; j<=je; j++) {
        for (int i=is; i<=ie; i++) {				        for (int i=is; i<=ie; i++) {
          Real& bcc1 = bb(IB1,k,j,i);				          Real& bcc1 = bb(IB1,k,j,i);
          Real& bcc2 = bb(IB2,k,j,i);				          Real& bcc2 = bb(IB2,k,j,i);
          Real& bcc3 = bb(IB3,k,j,i);				          Real& bcc3 = bb(IB3,k,j,i);

          phydro->u(IEN,k,j,i) += 0.5*(SQR(bcc1)+SQR(bcc2)+SQ	          phydro->u(IEN,k,j,i) += 0.5*(SQR(bcc1)+SQR(bcc2)+SQ
         }							         }
      }								      }
    }								    }
    a1.DeleteAthenaArray();					    a1.DeleteAthenaArray();
    a2.DeleteAthenaArray();					    a2.DeleteAthenaArray();
    a3.DeleteAthenaArray();					    a3.DeleteAthenaArray();
    area.DeleteAthenaArray();					    area.DeleteAthenaArray();
    len.DeleteAthenaArray();					    len.DeleteAthenaArray();
    len_p1.DeleteAthenaArray();					    len_p1.DeleteAthenaArray();
    bb.DeleteAthenaArray();					    bb.DeleteAthenaArray();
  } // end if MAGNETIC_FIELDS_ENABLED				  } // end if MAGNETIC_FIELDS_ENABLED
  // if root processor and last block				  // if root processor and last block
 // if ((Globals::my_rank == 0) && (lid == pmy_mesh->nblocal 	 // if ((Globals::my_rank == 0) && (lid == pmy_mesh->nblocal 
 //   std::cout<<"EXIT PGEN NOW NOW, finally right lol\n";	 //   std::cout<<"EXIT PGEN NOW NOW, finally right lol\n";
 // }								 // }
}								}


// Source Terms							// Source Terms
void heat_cool(MeshBlock *pmb, const Real time, const Real dt	void heat_cool(MeshBlock *pmb, const Real time, const Real dt
               const AthenaArray<Real> &prim, const AthenaArr	               const AthenaArray<Real> &prim, const AthenaArr
               const AthenaArray<Real> &bcc, AthenaArray<Real	               const AthenaArray<Real> &bcc, AthenaArray<Real
               AthenaArray<Real> &cons_scalar) {		               AthenaArray<Real> &cons_scalar) {
//  Real sumye = 0.0;						//  Real sumye = 0.0;
  for (int k=pmb->ks; k<=pmb->ke; ++k) {			  for (int k=pmb->ks; k<=pmb->ke; ++k) {
    for (int j=pmb->js; j<=pmb->je; ++j) {			    for (int j=pmb->js; j<=pmb->je; ++j) {
      for (int i=pmb->is; i<=pmb->ie; ++i) {			      for (int i=pmb->is; i<=pmb->ie; ++i) {
        Real erg2MeV  = 6.24151e5;				        Real erg2MeV  = 6.24151e5;
        Real r = pmb->pcoord->x1v(i);				        Real r = pmb->pcoord->x1v(i);
        Real p = prim(IPR,k,j,i);				        Real p = prim(IPR,k,j,i);
        Real rho = prim(IDN,k,j,i);				        Real rho = prim(IDN,k,j,i);

        edens = &cons_scalar(ye_index,k,j,i);			        edens = &cons_scalar(ye_index,k,j,i);
        Real Ye_i = prim_scalar(ye_index,k,j,i);		        Real Ye_i = prim_scalar(ye_index,k,j,i);
        efrac = &Ye_i;						        efrac = &Ye_i;
        Real temp = pmb->peos->TFromRhoP(rho, p, efrac) * 8.6	        Real temp = pmb->peos->TFromRhoP(rho, p, efrac) * 8.6
        Real x = std::sqrt(1.0-(r_0*r_0)/(r*r));		        Real x = std::sqrt(1.0-(r_0*r_0)/(r*r));
//        Real eta = QWEta(rho,temp/8.6173e-11,Ye_i);		//        Real eta = QWEta(rho,temp/8.6173e-11,Ye_i);
        //std::cout << "eta = " << eta << std::endl;		        //std::cout << "eta = " << eta << std::endl;
        Real vdYedr = YeSource(temp,Ye_i,x,rho)-YeSink(temp,Y	        Real vdYedr = YeSource(temp,Ye_i,x,rho)-YeSink(temp,Y
        Real dYe = dt*vdYedr;					        Real dYe = dt*vdYedr;
//        sumye += dYe;						//        sumye += dYe;
//        std::cout << "sumye (step) = " << sumye << std::end	//        std::cout << "sumye (step) = " << sumye << std::end
//        std::cout << "dt               = " << dt << std::en	//        std::cout << "dt               = " << dt << std::en
//        std::cout << "dYe = dt*vdYe/dr = " << dYe << std::e	//        std::cout << "dYe = dt*vdYe/dr = " << dYe << std::e
//        std::cout << " " << std::endl;			//        std::cout << " " << std::endl;
        cons_scalar(ye_index,k,j,i) += dYe*prim(IDN,k,j,i);	        cons_scalar(ye_index,k,j,i) += dYe*prim(IDN,k,j,i);
//        if (i==pmb->is) {					//        if (i==pmb->is) {
//          std::cout << "Ye                = " << Ye_i << st	//          std::cout << "Ye                = " << Ye_i << st
//          std::cout << "Ye (scalar field) = " << prim_scala	//          std::cout << "Ye (scalar field) = " << prim_scala
//        }							//        }

        // Real testingthing = Ye_f(temp, Ye_i, x);		        // Real testingthing = Ye_f(temp, Ye_i, x);
        //Real elecfrac = cons_scalar(ye_index,k,j,i)/prim(ID	        //Real elecfrac = cons_scalar(ye_index,k,j,i)/prim(ID

        //Real qdot = qdotQW(temp, x, elecfrac, time); //MeV 	        //Real qdot = qdotQW(temp, x, elecfrac, time); //MeV 
        //Real qdot = qdotQW(temp, x, Ye_i, time)/erg2MeV;  /	        //Real qdot = qdotQW(temp, x, Ye_i, time)/erg2MeV;  /
        Real qdot = qdotScheck_H(Ye_i,r) - qdotScheck_C(temp/	        Real qdot = qdotScheck_H(Ye_i,r) - qdotScheck_C(temp/
        //std::cout << "qdot = " << qdot << " erg/s/g" << std	        //std::cout << "qdot = " << qdot << " erg/s/g" << std
        Real de = dt*prim(IDN,k,j,i) * qdot; // * 1.6022e-6; 	        Real de = dt*prim(IDN,k,j,i) * qdot; // * 1.6022e-6; 
        cons(IEN,k,j,i) += de;					        cons(IEN,k,j,i) += de;
      }								      }
    }								    }
  }								  }
//  std::cout << " " << std::endl;				//  std::cout << " " << std::endl;
//  std::cout << "Sum Ye = " << sumye << std::endl;		//  std::cout << "Sum Ye = " << sumye << std::endl;
//  std::cout << " " << std::endl;				//  std::cout << " " << std::endl;
  return;							  return;
}								}


// Inflow Boundary Condition					// Inflow Boundary Condition
void InflowInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaAr	void InflowInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaAr
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh) {		                   int je, int ks, int ke, int ngh) {

  Real* Ye_eq_ptr = &Ye_eq;					  Real* Ye_eq_ptr = &Ye_eq;
  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    // Real phi = pco->x3v(k);					    // Real phi = pco->x3v(k);
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      Real theta = pco->x2v(j);					      Real theta = pco->x2v(j);
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        //Real r = pco->x1v(is);				        //Real r = pco->x1v(is);
	Real r = pco->x1v(is-i);					Real r = pco->x1v(is-i);
        prim(IDN,k,j,is-i) = rho_0;				        prim(IDN,k,j,is-i) = rho_0;
        prim(IVX,k,j,is-i) = (-1.0 * Mdot * (2.0e33)) / (4.0 	        prim(IVX,k,j,is-i) = (-1.0 * Mdot * (2.0e33)) / (4.0 
        prim(IVY,k,j,is-i) = 0.0;				        prim(IVY,k,j,is-i) = 0.0;
        prim(IVZ,k,j,is-i) = 0.0;				        prim(IVZ,k,j,is-i) = 0.0;
        // Setting inner ghost zone Ye equal to first active 	        // Setting inner ghost zone Ye equal to first active 
//        pmb->pscalars->r(ye_index,k,j,is-i) = pmb->pscalars	//        pmb->pscalars->r(ye_index,k,j,is-i) = pmb->pscalars
        pmb->pscalars->r(ye_index,k,j,is-i) = Ye_eq;		        pmb->pscalars->r(ye_index,k,j,is-i) = Ye_eq;
        if (NON_BAROTROPIC_EOS)					        if (NON_BAROTROPIC_EOS)
          prim(IPR,k,j,is-i) = p_0; //pmb->peos->PresFromRhoT	          prim(IPR,k,j,is-i) = p_0; //pmb->peos->PresFromRhoT
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);			          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);			          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);			          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

// Inflow Boundary Condition					// Inflow Boundary Condition
void InflowMdotInnerX1(MeshBlock *pmb, Coordinates *pco, Athe	void InflowMdotInnerX1(MeshBlock *pmb, Coordinates *pco, Athe
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh) {		                   int je, int ks, int ke, int ngh) {
  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    // Real phi = pco->x3v(k);					    // Real phi = pco->x3v(k);
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      Real theta = pco->x2v(j);					      Real theta = pco->x2v(j);
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        prim(IDN,k,j,is-i) = rho_0;				        prim(IDN,k,j,is-i) = rho_0;
        Real v = prim(IVX,k,j,is) * SQR(pco->x1v(is) / pco->x	        Real v = prim(IVX,k,j,is) * SQR(pco->x1v(is) / pco->x
        prim(IVX,k,j,is-i) = std::max(v, 0.0);			        prim(IVX,k,j,is-i) = std::max(v, 0.0);
        prim(IVY,k,j,is-i) = 0.0;				        prim(IVY,k,j,is-i) = 0.0;
        prim(IVZ,k,j,is-i) = 0.0;				        prim(IVZ,k,j,is-i) = 0.0;
        if (NON_BAROTROPIC_EOS)					        if (NON_BAROTROPIC_EOS)
          prim(IPR,k,j,is-i) = p_0;				          prim(IPR,k,j,is-i) = p_0;
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);			          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);			          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);			          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

void HSEInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArray	void HSEInnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArray
                FaceField &b, Real time, Real dt, int is, int	                FaceField &b, Real time, Real dt, int is, int
                int je, int ks, int ke, int ngh) {		                int je, int ks, int ke, int ngh) {

  Real r0 = pco->x1v(is);					  Real r0 = pco->x1v(is);
  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    // Real phi = pco->x3v(k);					    // Real phi = pco->x3v(k);
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      Real theta = pco->x2v(j);					      Real theta = pco->x2v(j);
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        Real r = pco->x1v(is-i);				        Real r = pco->x1v(is-i);
        prim(IDN,k,j,is-i) = rho_0 * std::exp((r0 - r) * mu /	        prim(IDN,k,j,is-i) = rho_0 * std::exp((r0 - r) * mu /
        Real v = prim(IVX,k,j,is) * prim(IDN,k,j,is) / prim(I	        Real v = prim(IVX,k,j,is) * prim(IDN,k,j,is) / prim(I
        prim(IVX,k,j,is-i) = std::max(v, 0.0);			        prim(IVX,k,j,is-i) = std::max(v, 0.0);
        prim(IVY,k,j,is-i) = 0.0;				        prim(IVY,k,j,is-i) = 0.0;
        prim(IVZ,k,j,is-i) = 0.0;				        prim(IVZ,k,j,is-i) = 0.0;
        if (NON_BAROTROPIC_EOS) {				        if (NON_BAROTROPIC_EOS) {
          prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(prim(I	          prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(prim(I
        }							        }
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);			          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);			          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);			          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

void HSE2InnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArra	void HSE2InnerX1(MeshBlock *pmb, Coordinates *pco, AthenaArra
                 FaceField &b, Real time, Real dt, int is, in	                 FaceField &b, Real time, Real dt, int is, in
                int je, int ks, int ke, int ngh) {		                int je, int ks, int ke, int ngh) {
  AthenaArray<Real> out1;					  AthenaArray<Real> out1;
  out1.NewAthenaArray(7);					  out1.NewAthenaArray(7);
  Real r0 = pco->x1v(is);					  Real r0 = pco->x1v(is);
  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    // Real phi = pco->x3v(k);					    // Real phi = pco->x3v(k);
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      Real theta = pco->x2v(j);					      Real theta = pco->x2v(j);
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        Real r = pco->x1v(is-i);				        Real r = pco->x1v(is-i);
        prim(IDN,k,j,is-i) = rho_0 * std::exp((r0 - r) * mu /	        prim(IDN,k,j,is-i) = rho_0 * std::exp((r0 - r) * mu /
        prim(IVX,k,j,is-i) = std::max(prim(IVX,k,j,is), 0.0);	        prim(IVX,k,j,is-i) = std::max(prim(IVX,k,j,is), 0.0);
        prim(IVY,k,j,is-i) = 0.0;				        prim(IVY,k,j,is-i) = 0.0;
        prim(IVZ,k,j,is-i) = 0.0;				        prim(IVZ,k,j,is-i) = 0.0;
        if (NON_BAROTROPIC_EOS) {				        if (NON_BAROTROPIC_EOS) {
          prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(prim(I	          prim(IPR,k,j,is-i) = pmb->peos->PresFromRhoT(prim(I
        }							        }
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);			          b.x1f(k,j,(is-i)) = b.x1f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);			          b.x2f(k,j,(is-i)) = b.x2f(k,j,is);
        }							        }
      }								      }
    }								    }

    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);			          b.x3f(k,j,(is-i)) = b.x3f(k,j,is);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

// Outflow Boundary Condition					// Outflow Boundary Condition
void OutflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaA	void OutflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaA
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh) {		                   int je, int ks, int ke, int ngh) {
  Real re = pco->x1v(ie);					  Real re = pco->x1v(ie);
  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        Real rgh = pco->x1v(ie+i);				        Real rgh = pco->x1v(ie+i);
        Real ratio = re / rgh;					        Real ratio = re / rgh;
        prim(IDN,k,j,ie+i) = prim(IDN,k,j,ie) * SQR(ratio);	        prim(IDN,k,j,ie+i) = prim(IDN,k,j,ie) * SQR(ratio);
        prim(IVX,k,j,ie+i) = std::max(prim(IVX,k,j,ie), 0.0);	        prim(IVX,k,j,ie+i) = std::max(prim(IVX,k,j,ie), 0.0);
        prim(IVY,k,j,ie+i) = prim(IVY,k,j,ie) * ratio;		        prim(IVY,k,j,ie+i) = prim(IVY,k,j,ie) * ratio;
        prim(IVZ,k,j,ie+i) = prim(IVZ,k,j,ie) * ratio;		        prim(IVZ,k,j,ie+i) = prim(IVZ,k,j,ie) * ratio;
        if (NON_BAROTROPIC_EOS)					        if (NON_BAROTROPIC_EOS)
          prim(IPR,k,j,ie+i) = prim(IPR,k,j,ie); // Constant 	          prim(IPR,k,j,ie+i) = prim(IPR,k,j,ie); // Constant 
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(ie+i+1)) = b.x1f(k,j,(ie+1));		          b.x1f(k,j,(ie+i+1)) = b.x1f(k,j,(ie+1));
        }							        }
      }								      }
    }								    }
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(ie+i)) = b.x2f(k,j,ie);			          b.x2f(k,j,(ie+i)) = b.x2f(k,j,ie);
        }							        }
      }								      }
    }								    }
    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(ie+i)) = b.x3f(k,j,ie);			          b.x3f(k,j,(ie+i)) = b.x3f(k,j,ie);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

// Inflow Boundary Condition at outer boundary			// Inflow Boundary Condition at outer boundary
void InflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaAr	void InflowOuterX1(MeshBlock *pmb, Coordinates *pco, AthenaAr
                   FaceField &b, Real time, Real dt, int is, 	                   FaceField &b, Real time, Real dt, int is, 
                   int je, int ks, int ke, int ngh) {		                   int je, int ks, int ke, int ngh) {
 // Real re = pco->x1v(ie);					 // Real re = pco->x1v(ie);
  for (int k=ks; k<=ke; ++k) {					  for (int k=ks; k<=ke; ++k) {
    for (int j=js; j<=je; ++j) {				    for (int j=js; j<=je; ++j) {
      Real theta = pco->x2v(j);					      Real theta = pco->x2v(j);
      for (int i=1; i<=ngh; ++i) {				      for (int i=1; i<=ngh; ++i) {
        prim(IDN,k,j,ie+i) = rho_f;				        prim(IDN,k,j,ie+i) = rho_f;
        prim(IVX,k,j,ie+i) = v_f;				        prim(IVX,k,j,ie+i) = v_f;
        prim(IPR,k,j,ie+i) = p_f;				        prim(IPR,k,j,ie+i) = p_f;
        prim(IVY,k,j,ie+i) = 0.0;				        prim(IVY,k,j,ie+i) = 0.0;
        prim(IVZ,k,j,ie+i) = 0.0;				        prim(IVZ,k,j,ie+i) = 0.0;
        pmb->pscalars->r(ye_index,k,j,ie+i)=ye_const;		        pmb->pscalars->r(ye_index,k,j,ie+i)=ye_const;
//        std::cout << "Outer BC" << std::endl;			//        std::cout << "Outer BC" << std::endl;
//        std::cout << "ie+i = " << ie+i << std::endl;		//        std::cout << "ie+i = " << ie+i << std::endl;
   //     if (NON_BAROTROPIC_EOS)				   //     if (NON_BAROTROPIC_EOS)
   //       prim(IPR,k,j,ie+i) = prim(IPR,k,j,ie); // Constan	   //       prim(IPR,k,j,ie+i) = prim(IPR,k,j,ie); // Constan
      }								      }
    }								    }
  }								  }

  // copy face-centered magnetic fields into ghost zones	  // copy face-centered magnetic fields into ghost zones
  if (MAGNETIC_FIELDS_ENABLED) {				  if (MAGNETIC_FIELDS_ENABLED) {
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x1f(k,j,(ie+i+1)) = b.x1f(k,j,(ie+1));		          b.x1f(k,j,(ie+i+1)) = b.x1f(k,j,(ie+1));
        }							        }
      }								      }
    }								    }
    for (int k=ks; k<=ke; ++k) {				    for (int k=ks; k<=ke; ++k) {
      for (int j=js; j<=je+1; ++j) {				      for (int j=js; j<=je+1; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x2f(k,j,(ie+i)) = b.x2f(k,j,ie);			          b.x2f(k,j,(ie+i)) = b.x2f(k,j,ie);
        }							        }
      }								      }
    }								    }
    for (int k=ks; k<=ke+1; ++k) {				    for (int k=ks; k<=ke+1; ++k) {
      for (int j=js; j<=je; ++j) {				      for (int j=js; j<=je; ++j) {
#pragma omp simd						#pragma omp simd
        for (int i=1; i<=ngh; ++i) {				        for (int i=1; i<=ngh; ++i) {
          b.x3f(k,j,(ie+i)) = b.x3f(k,j,ie);			          b.x3f(k,j,(ie+i)) = b.x3f(k,j,ie);
        }							        }
      }								      }
    }								    }
  }								  }
}								}

void MeshBlock::UserWorkBeforeOutput(ParameterInput *pin) {	void MeshBlock::UserWorkBeforeOutput(ParameterInput *pin) {
  for(int k=ks; k<=ke; k++) {					  for(int k=ks; k<=ke; k++) {
    for(int j=js; j<=je; j++) {					    for(int j=js; j<=je; j++) {

      for(int i=is; i<=ie; i++) {				      for(int i=is; i<=ie; i++) {
//        pscalars->s(ye_index,k,j,i)=ye_const*phydro->u(IDN,	//        pscalars->s(ye_index,k,j,i)=ye_const*phydro->u(IDN,
//        pscalars->r(ye_index,k,j,i)=pscalars->s(ye_index,k,	//        pscalars->r(ye_index,k,j,i)=pscalars->s(ye_index,k,
        edens = &pscalars->s(ye_index,k,j,i);			        edens = &pscalars->s(ye_index,k,j,i);
        efrac = &pscalars->r(ye_index,k,j,i);			        efrac = &pscalars->r(ye_index,k,j,i);
//        std::cout << "edens = " << edens << std::endl;	//        std::cout << "edens = " << edens << std::endl;
//        std::cout << "efrac (UserWorkBeforeOutput) = " << p	//        std::cout << "efrac (UserWorkBeforeOutput) = " << p
        Real temp=peos->TFromRhoP(phydro->w(IDN,k,j,i),phydro	        Real temp=peos->TFromRhoP(phydro->w(IDN,k,j,i),phydro
        // Real egas= peos->EgasFromRhoP(phydro->w(IDN,k,j,i)	        // Real egas= peos->EgasFromRhoP(phydro->w(IDN,k,j,i)
        // Real temp2= peos->TFromRhoEgas(phydro->w(IDN,k,j,i	        // Real temp2= peos->TFromRhoEgas(phydro->w(IDN,k,j,i

        user_out_var(0,k,j,i) = temp;				        user_out_var(0,k,j,i) = temp;
        Real r = pcoord->x1v(i);				        Real r = pcoord->x1v(i);

        temp *= 8.6173e-11; //convert to MeV			        temp *= 8.6173e-11; //convert to MeV
        Real x=std::pow((1.0-(r_0*r_0)/(r*r)),0.5);		        Real x=std::pow((1.0-(r_0*r_0)/(r*r)),0.5);
//        Real qdot = qdotQW(temp, x, pscalars->r(ye_index,k,	//        Real qdot = qdotQW(temp, x, pscalars->r(ye_index,k,
//        Real qdot = qdotScheck_H(pscalars->r(ye_index,k,j,i	//        Real qdot = qdotScheck_H(pscalars->r(ye_index,k,j,i
//                    qdotScheck_C(temp/8.6173e-11,pscalars->	//                    qdotScheck_C(temp/8.6173e-11,pscalars->
//        Real yef  = Ye_f(temp, pscalars->r(ye_index,k,j,i),	//        Real yef  = Ye_f(temp, pscalars->r(ye_index,k,j,i),
        Real eta = QWEta(phydro->u(IDN<k,j,i),temp/8.6173e-11	        Real eta = QWEta(phydro->u(IDN<k,j,i),temp/8.6173e-11
        user_out_var(1,k,j,i) = qdotScheck_H(pscalars->r(ye_i	        user_out_var(1,k,j,i) = qdotScheck_H(pscalars->r(ye_i
        user_out_var(2,k,j,i) = std::sqrt(peos->AsqFromRhoP(p	        user_out_var(2,k,j,i) = std::sqrt(peos->AsqFromRhoP(p
                                                            p	                                                            p
//        user_out_var(2,k,j,i) = qdotScheck_C(temp/8.6173e-1	//        user_out_var(2,k,j,i) = qdotScheck_C(temp/8.6173e-1
      }								      }
    }								    }
  }								  }
}								}
