#define MYDEBUG1					      |	//#define MYDEBUG1
//===========================================================	//===========================================================
// Athena++ astrophysical MHD code				// Athena++ astrophysical MHD code
// Copyright(C) 2014 James M. Stone <jmstone@princeton.edu> a	// Copyright(C) 2014 James M. Stone <jmstone@princeton.edu> a
// Licensed under the 3-clause BSD License, see LICENSE file 	// Licensed under the 3-clause BSD License, see LICENSE file 
//===========================================================	//===========================================================
//! \file eos_qw.cpp					      |	//! \file qw_eos.cpp
//! \brief implements functions in class EquationOfState for 	//! \brief implements functions in class EquationOfState for 
//===========================================================	//===========================================================

// C headers							// C headers

// C++ headers							// C++ headers
#include <algorithm>						#include <algorithm>
#include <cmath>   // sqrt()					#include <cmath>   // sqrt()
#include <fstream>						#include <fstream>
#include <iostream> // ifstream					#include <iostream> // ifstream
#include <limits>   // std::numeric_limits<float>::epsilon()	#include <limits>   // std::numeric_limits<float>::epsilon()
#include <sstream>						#include <sstream>
#include <stdexcept> // std::invalid_argument			#include <stdexcept> // std::invalid_argument
#include <string>						#include <string>

// Athena++ headers						// Athena++ headers
#include "../../athena.hpp"					#include "../../athena.hpp"
#include "../../athena_arrays.hpp"				#include "../../athena_arrays.hpp"
#include "../../coordinates/coordinates.hpp"			#include "../../coordinates/coordinates.hpp"
#include "../../field/field.hpp"				#include "../../field/field.hpp"
#include "../../parameter_input.hpp"				#include "../../parameter_input.hpp"
#include "../eos.hpp"						#include "../eos.hpp"

// Same effect as adding static to everything inside	      <
namespace {							namespace {
  // const Real float_eps = std::numeric_limits<Real>::epsilo <
  // const Real float_1pe = 1.0 + float_eps;		      <
  const Real float_max = std::numeric_limits<Real>::max();	  const Real float_max = std::numeric_limits<Real>::max();
  Real prec = 1e-8;						  Real prec = 1e-8;
  Real T_floor, T_ceil, LastTemp;				  Real T_floor, T_ceil, LastTemp;
  Real fixed_ye = -1.0;					      <
  int i_ye = -1;					      <
  bool use_T_floor;						  bool use_T_floor;
  int nmax;							  int nmax;
							      >	  Real fixed_ye = -1.0;
							      >	  int i_ye = -1;
  AthenaArray<Real> EosData;					  AthenaArray<Real> EosData;

  const Real third = 1.0 / 3.0;					  const Real third = 1.0 / 3.0;
  const Real c = 2.99792458e10;					  const Real c = 2.99792458e10;
  const Real k = 1.380649e-16;					  const Real k = 1.380649e-16;
  const Real mn = 1.6726e-24;					  const Real mn = 1.6726e-24;
  const Real hbar = 6.62607015e-27/(2.0*PI);			  const Real hbar = 6.62607015e-27/(2.0*PI);
  const Real c3 = std::pow(k/(hbar*c),3);			  const Real c3 = std::pow(k/(hbar*c),3);
  const Real con3 = (11.0*PI*PI/180.0)*c3*k;			  const Real con3 = (11.0*PI*PI/180.0)*c3*k;
  const Real Tmin=1e3;						  const Real Tmin=1e3;
  const Real Tmax=1e15;						  const Real Tmax=1e15;
  const Real kmn=k/mn;						  const Real kmn=k/mn;
  const Real thel= 30.0/11.0;					  const Real thel= 30.0/11.0;
  const Real fiel= 15.0/11.0;					  const Real fiel= 15.0/11.0;
  const Real eta_den_const = std::pow(6.0,2.0*third);		  const Real eta_den_const = std::pow(6.0,2.0*third);
							      >	  const Real root3 = std::sqrt(3.0);
							      >	  const Real eta_den_A = std::pow(2.0,third) / eta_den_const;
							      >	  const Real eta_den_B = 2.0*std::pow(3.0,third)/eta_den_cons
} // namespace							} // namespace

// EOS data indicies						// EOS data indicies
namespace EOS {							namespace EOS {
  enum EosIndex {iE=0, idEdT=1, iP=2, idPdT=3, iAsq=4, iT=5, 	  enum EosIndex {iE=0, idEdT=1, iP=2, idPdT=3, iAsq=4, iT=5, 
}								}

							      <
Real PorE(Real rho, Real T, Real Ye, int index) {		Real PorE(Real rho, Real T, Real Ye, int index) {
  Real vol = mn/rho;						  Real vol = mn/rho;
  Real T4 = T*T*T*T;						  Real T4 = T*T*T*T;
  Real a = c3*std::pow(T,3.0)*vol*(PI/3.0);			  Real a = c3*std::pow(T,3.0)*vol*(PI/3.0);
  Real a2 = SQR(a);						  Real a2 = SQR(a);
  Real a4 = SQR(a2);						  Real a4 = SQR(a2);
  Real a6 = a2 * a4;						  Real a6 = a2 * a4;
  Real y2 = SQR(Ye);						  Real y2 = SQR(Ye);
  Real b = std::sqrt(4.0*a6+27.0*a4*y2);			  Real b = std::sqrt(4.0*a6+27.0*a4*y2);
  Real term = std::pow(9.0*a2*Ye+std::pow(3.0,0.5)*b, third); |	  Real term = std::pow(9.0*a2*Ye+root3*b, third);
  Real eta = (std::pow(2.0,third)/eta_den_const)*term/a - (2. |	  Real eta = eta_den_A*term/a - eta_den_B*a/term; // actually
							      <
  Real eta2 = SQR(eta);						  Real eta2 = SQR(eta);
							      <
  Real eta4 = SQR(eta2);					  Real eta4 = SQR(eta2);

  Real con= con3*(1.0+thel*eta2 + fiel*eta4);		      |	  Real con = con3*(1.0+thel*eta2 + fiel*eta4);
  Real p0 = rho*kmn*T;						  Real p0 = rho*kmn*T;
  if (index == EOS::iP) {					  if (index == EOS::iP) {
    return con*T4 + p0;						    return con*T4 + p0;
  } else if (index == EOS::iE) {				  } else if (index == EOS::iE) {
    return 3.0*con*T4 + 1.5*p0;					    return 3.0*con*T4 + 1.5*p0;
  }								  }
  std::cout<<"Incorrect index in PorE \n";			  std::cout<<"Incorrect index in PorE \n";
  return 0;							  return 0;
}								}

							      <
							      <
							      <
void QWData(Real rho, Real T, Real Ye, AthenaArray<Real> &Out	void QWData(Real rho, Real T, Real Ye, AthenaArray<Real> &Out
  //if (use_T_floor){					      <
    //std::cout<<"ENTER IF IN QWDATA \n";		      <
    //T = std::max(T, T_floor);				      <
  //}							      <
  Real vol = mn/rho;						  Real vol = mn/rho;
  Real T3 = T*T*T;						  Real T3 = T*T*T;
  Real T4 = T*T3;						  Real T4 = T*T3;
  Real a = c3*std::pow(T,3)*vol*(PI/3.0);			  Real a = c3*std::pow(T,3)*vol*(PI/3.0);
  Real a2 = SQR(a);						  Real a2 = SQR(a);
  Real a4 = SQR(a2);						  Real a4 = SQR(a2);
  Real a6 = a2 * a4;						  Real a6 = a2 * a4;
  Real y2 = SQR(Ye);						  Real y2 = SQR(Ye);
  Real b = std::sqrt(4.0*a6+27.0*a4*y2);			  Real b = std::sqrt(4.0*a6+27.0*a4*y2);
  Real term = std::pow(9.0*a2*Ye+std::pow(3.0,0.5)*b, third); |	  Real term = std::pow(9.0*a2*Ye+root3*b, third);
  Real eta = (std::pow(2.0,third)/eta_den_const)*term/a - (2. |	  Real eta = (eta_den_A)*term/a - (eta_den_B)*a/term; // actu
  							      <
  Real eta2 = SQR(eta);						  Real eta2 = SQR(eta);
  Real eta3 = eta*eta2;						  Real eta3 = eta*eta2;
  Real eta4 = SQR(eta2);					  Real eta4 = SQR(eta2);

  Real da_dt = 3.0*a/T;						  Real da_dt = 3.0*a/T;
  Real dterm_dt= third*std::pow(term, -2)*(18.0*a*Ye*da_dt	  Real dterm_dt= third*std::pow(term, -2)*(18.0*a*Ye*da_dt
                + std::pow(3.0,0.5)*0.5*a*(24.0*a4*da_dt+27.0 |	                + root3*0.5*a*(24.0*a4*da_dt+27.0*4.0*a2*y2*d
  Real der_eta = (std::pow(2.0,third)/eta_den_const)*(dterm_d |	  Real der_eta = (eta_den_A)*(dterm_dt/a - term*da_dt/(a*a))
                 - (2.0*std::pow(3.0,third)/eta_den_const)*(d |	                 - (eta_den_B)*(da_dt/term -a*dterm_dt/(term*

  Real con= con3*(1.0+thel*eta2 + fiel*eta4);			  Real con= con3*(1.0+thel*eta2 + fiel*eta4);
  Real p0 = rho*kmn*T;						  Real p0 = rho*kmn*T;
  Real P = con*T4 + p0;						  Real P = con*T4 + p0;
  Real e = 3.0*con*T4 + 1.5*p0;					  Real e = 3.0*con*T4 + 1.5*p0;

  Real der_P= 4.0*T3*con + con3*T4*(thel*2.0*eta*der_eta	  Real der_P= 4.0*T3*con + con3*T4*(thel*2.0*eta*der_eta
                                    + fiel*4.0*eta3*der_eta);	                                    + fiel*4.0*eta3*der_eta);
  Real der_e= 3.0*der_P+ 1.5*rho*kmn;				  Real der_e= 3.0*der_P+ 1.5*rho*kmn;
  der_P += rho*kmn;						  der_P += rho*kmn;

  Real deta_drho = (eta/rho)*(1.0+eta2)/(1.0+3.0*eta2); //act |	  Real ctsq=kmn*T;
  Real ctsq=kmn*T + con3*T4*4.0*fiel*eta*deta_drho*(1.0+eta2) <
  Real D=(T/rho)*der_P;						  Real D=(T/rho)*der_P;
  Real cv= der_e / rho;						  Real cv= der_e / rho;
  Real asq = ctsq+D*D/(cv*T);					  Real asq = ctsq+D*D/(cv*T);

  OutData(0) = e;						  OutData(0) = e;
  OutData(1) = der_e;						  OutData(1) = der_e;
  OutData(2) = P;						  OutData(2) = P;
  OutData(3) = der_P;						  OutData(3) = der_P;
  OutData(4) = asq;						  OutData(4) = asq;
  OutData(5) = T;						  OutData(5) = T;

#ifdef MYDEBUG1							#ifdef MYDEBUG1
  bool flag = false;						  bool flag = false;
  for (int i=0; i<6; ++i) {					  for (int i=0; i<6; ++i) {
    if (!std::isfinite(OutData(i)))				    if (!std::isfinite(OutData(i)))
      flag = true;						      flag = true;
  }								  }
  if (flag) {							  if (flag) {
    printf("ERR: Non-finite output detected in EOS output.\n"	    printf("ERR: Non-finite output detected in EOS output.\n"
    printf("e_int, de/dT, P_gas, dP/dT,   a^2,  Temp,  dens\n	    printf("e_int, de/dT, P_gas, dP/dT,   a^2,  Temp,  dens\n
    printf("EOS data: ");					    printf("EOS data: ");
    for (int i=0; i<6; ++i)					    for (int i=0; i<6; ++i)
      printf("%.4e, ", OutData(i));				      printf("%.4e, ", OutData(i));
    printf("%.4e\n", rho);					    printf("%.4e\n", rho);
    std::stringstream msg;					    std::stringstream msg;
    msg << "### FATAL ERROR in QWData" << std::endl		    msg << "### FATAL ERROR in QWData" << std::endl
        << "Non-finite value in EOS data." << std::endl;	        << "Non-finite value in EOS data." << std::endl;
    ATHENA_ERROR(msg);						    ATHENA_ERROR(msg);
  }								  }
#endif // MYDEBUG1						#endif // MYDEBUG1
}								}

							      <
							      <
							      <
// index = 0 for internal energy; index = 2 for pressure; var	// index = 0 for internal energy; index = 2 for pressure; var
void TempInvert(Real rho, Real GuessTemp, Real Ye, Real var, 	void TempInvert(Real rho, Real GuessTemp, Real Ye, Real var, 
                AthenaArray<Real> &OutData) {			                AthenaArray<Real> &OutData) {
  if ((std::isnan(var)) || (std::isnan(rho)) || (std::isnan(G	  if ((std::isnan(var)) || (std::isnan(rho)) || (std::isnan(G
      const char *varnames[] = {"e_int", "de_int/dT", "P_gas"	      const char *varnames[] = {"e_int", "de_int/dT", "P_gas"
      printf("ERR (%s): %.4e, rho: %.4e,  Temp: %.4e \n", var	      printf("ERR (%s): %.4e, rho: %.4e,  Temp: %.4e \n", var
             GuessTemp);					             GuessTemp);

      std::stringstream msg;					      std::stringstream msg;
      msg <<"Nan in root find (var) \n";			      msg <<"Nan in root find (var) \n";
      ATHENA_ERROR(msg);					      ATHENA_ERROR(msg);
    }								    }
  if ((var<=0.0) || (rho<=0.0)) {				  if ((var<=0.0) || (rho<=0.0)) {
      const char *varnames[] = {"e_int", "de_int/dT", "P_gas"	      const char *varnames[] = {"e_int", "de_int/dT", "P_gas"
      printf("ERR (%s): %.4e, rho: %.4e,  Temp: %.4e \n", var	      printf("ERR (%s): %.4e, rho: %.4e,  Temp: %.4e \n", var
             GuessTemp);					             GuessTemp);

      std::stringstream msg;					      std::stringstream msg;
      msg <<"Negative var\n";					      msg <<"Negative var\n";
      ATHENA_ERROR(msg);					      ATHENA_ERROR(msg);
  }								  }

  Real tt1;							  Real tt1;
  if (index == EOS::iP) {					  if (index == EOS::iP) {
    tt1 = std::pow(var / con3, .25);				    tt1 = std::pow(var / con3, .25);

    Real v1= PorE(rho,tt1,Ye,index);				    Real v1= PorE(rho,tt1,Ye,index);
    Real v3= PorE(rho,GuessTemp,Ye,index);			    Real v3= PorE(rho,GuessTemp,Ye,index);
    Real rat1=std::abs(var/v1-1.0);				    Real rat1=std::abs(var/v1-1.0);
    Real rat3=std::abs(var/v3-1.0);				    Real rat3=std::abs(var/v3-1.0);
    if(rat1<rat3) {						    if(rat1<rat3) {
      GuessTemp=tt1;						      GuessTemp=tt1;
    }								    }
  }								  }

  if (index == EOS::iE) {					  if (index == EOS::iE) {
    tt1 = std::pow(var / (3.0 * con3), .25);			    tt1 = std::pow(var / (3.0 * con3), .25);
    Real v1= PorE(rho,tt1,Ye,index);				    Real v1= PorE(rho,tt1,Ye,index);
    Real v3= PorE(rho,GuessTemp,Ye,index);			    Real v3= PorE(rho,GuessTemp,Ye,index);
    Real rat1=std::abs(var/v1-1.0);				    Real rat1=std::abs(var/v1-1.0);
    Real rat3=std::abs(var/v3-1.0);				    Real rat3=std::abs(var/v3-1.0);
    if(rat1<rat3) {						    if(rat1<rat3) {
      GuessTemp=tt1;						      GuessTemp=tt1;
    }								    }
  }								  }

  Real BrakT[] = {T_floor,T_ceil};				  Real BrakT[] = {T_floor,T_ceil};
  Real BrakVal[] = {0, 0};					  Real BrakVal[] = {0, 0};
  Real InvVar = 1.0 / var;					  Real InvVar = 1.0 / var;
  Real error = float_max;					  Real error = float_max;
  int nlim = nmax;						  int nlim = nmax;
  Real LastTemp = BrakT[0];					  Real LastTemp = BrakT[0];
  QWData(rho, LastTemp,Ye, OutData);			      |	  QWData(rho, LastTemp, Ye, OutData);
  BrakVal[0] = OutData(index) * InvVar - 1.0;			  BrakVal[0] = OutData(index) * InvVar - 1.0;
  Real LastErr = BrakVal[0];					  Real LastErr = BrakVal[0];
  Real delta;							  Real delta;
#ifdef MYDEBUG1							#ifdef MYDEBUG1
  //printf("%d: %.16e, %.16e\n", index, var, rho);		  //printf("%d: %.16e, %.16e\n", index, var, rho);
  int mode = 0;							  int mode = 0;
#endif								#endif
  while (std::abs(error) > prec) {				  while (std::abs(error) > prec) {
    if(std::isnan(GuessTemp)) {					    if(std::isnan(GuessTemp)) {
      break;							      break;
    }								    }
    if (BrakVal[0] > 0) {					    if (BrakVal[0] > 0) {
      QWData(rho, BrakT[0],Ye, OutData);		      |	      QWData(rho, BrakT[0], Ye, OutData);
      Real low = OutData(index);				      Real low = OutData(index);
      // If we are below Tmin					      // If we are below Tmin
      if (var < low) {						      if (var < low) {
        Real rtemp;						        Real rtemp;
        if (index == EOS::iP) {					        if (index == EOS::iP) {
          rtemp = std::min(std::pow(var / con3, .25), var/ (k	          rtemp = std::min(std::pow(var / con3, .25), var/ (k
          QWData(rho, rtemp,Ye, OutData);		      |	          QWData(rho, rtemp, Ye, OutData);
        } else if (index == EOS::iE) {				        } else if (index == EOS::iE) {
          rtemp = std::min(std::pow(var / (3.0 * con3), .25),	          rtemp = std::min(std::pow(var / (3.0 * con3), .25),
          QWData(rho, rtemp,Ye, OutData);		      |	          QWData(rho, rtemp, Ye, OutData);
        }							        }
        return;							        return;
      }								      }
      QWData(rho, BrakT[1],Ye, OutData);		      |	      QWData(rho, BrakT[1], Ye, OutData);
      Real high =  OutData(index);				      Real high =  OutData(index);
      std::stringstream msg;					      std::stringstream msg;
      const char *varnames[] = {"e_int", "de_int/dT", "P_gas"	      const char *varnames[] = {"e_int", "de_int/dT", "P_gas"
      printf("0 ERR (%s): %.4e !<= %.4e !<= %.4e\n", varnames	      printf("0 ERR (%s): %.4e !<= %.4e !<= %.4e\n", varnames
             high);						             high);
      printf("at rho = %.4e, T_bounds = %.4e, %.4e,\n", rho, 	      printf("at rho = %.4e, T_bounds = %.4e, %.4e,\n", rho, 

      msg << "### FATAL ERROR in EquationOfState inversion (T	      msg << "### FATAL ERROR in EquationOfState inversion (T
          << std::endl << "Root not bracketed" << std::endl;	          << std::endl << "Root not bracketed" << std::endl;
      ATHENA_ERROR(msg);					      ATHENA_ERROR(msg);
    }								    }

    // if we are outside brackets use bisection method for a 	    // if we are outside brackets use bisection method for a 
    if ((GuessTemp <= BrakT[0]) || (GuessTemp >= BrakT[1])) {	    if ((GuessTemp <= BrakT[0]) || (GuessTemp >= BrakT[1])) {
      if((BrakT[0]<= 0.0) || (BrakT[1]<= 0.0)) {		      if((BrakT[0]<= 0.0) || (BrakT[1]<= 0.0)) {
        Real rtemp;						        Real rtemp;
        if (index == EOS::iP) {					        if (index == EOS::iP) {
          rtemp = std::min(std::pow(var / con3, .25), var/ (k	          rtemp = std::min(std::pow(var / con3, .25), var/ (k
          QWData(rho, rtemp,Ye, OutData);		      |	          QWData(rho, rtemp, Ye, OutData);
          //std::cout<<"Var:pres, BrakT<0   "<<rho<<"    "<<v	          //std::cout<<"Var:pres, BrakT<0   "<<rho<<"    "<<v
        } else if (index == EOS::iE) {				        } else if (index == EOS::iE) {
          rtemp = std::min(std::pow(var / (3.0 * con3), .25),	          rtemp = std::min(std::pow(var / (3.0 * con3), .25),
          QWData(rho, rtemp,Ye, OutData);		      |	          QWData(rho, rtemp, Ye, OutData);
          //std::cout<<"Var:egas, BrakT<0   "<<rho<<"    "<<v	          //std::cout<<"Var:egas, BrakT<0   "<<rho<<"    "<<v
        }							        }
        return;							        return;
      }								      }

      GuessTemp = std::sqrt(BrakT[0] * BrakT[1]);		      GuessTemp = std::sqrt(BrakT[0] * BrakT[1]);
      //if(std::isnan(GuessTemp)) {				      //if(std::isnan(GuessTemp)) {
      //  std::cout<<"Nan guessT in brak   "<<BrakT[0]<<"    	      //  std::cout<<"Nan guessT in brak   "<<BrakT[0]<<"    
      //}							      //}
#ifdef MYDEBUG1							#ifdef MYDEBUG1
      mode = 1;							      mode = 1;
#endif								#endif
    }								    }
    QWData(rho, GuessTemp,Ye, OutData);			      |	    QWData(rho, GuessTemp, Ye, OutData);
    error = OutData(index) * InvVar - 1.0;			    error = OutData(index) * InvVar - 1.0;
#ifdef MYDEBUG1							#ifdef MYDEBUG1
    if(GuessTemp<0.0 ||(std::isnan(GuessTemp))) {		    if(GuessTemp<0.0 ||(std::isnan(GuessTemp))) {
      printf("%04d [%.4g, %.4g, %.4g]; %.4g| %d\n", 10000 - n	      printf("%04d [%.4g, %.4g, %.4g]; %.4g| %d\n", 10000 - n
             BrakT[1], error, mode);				             BrakT[1], error, mode);
    }								    }
#endif								#endif
    // update bracketing values					    // update bracketing values
    if (error < 0) {						    if (error < 0) {
      BrakT[0] = GuessTemp;					      BrakT[0] = GuessTemp;
      BrakVal[0] = error;					      BrakVal[0] = error;
    } else {							    } else {
      BrakT[1] = GuessTemp;					      BrakT[1] = GuessTemp;
      BrakVal[1] = error;					      BrakVal[1] = error;
    }								    }
    if (BrakT[1] <= BrakT[0]) {					    if (BrakT[1] <= BrakT[0]) {
      QWData(rho, BrakT[0],Ye, OutData);		      |	      QWData(rho, BrakT[0], Ye, OutData);
      Real low = OutData(index);				      Real low = OutData(index);
      // If we've specified Tfloor and we are below Tmin just	      // If we've specified Tfloor and we are below Tmin just
      if (var < low) {						      if (var < low) {
        Real rtemp;						        Real rtemp;
        if (index == EOS::iP) {					        if (index == EOS::iP) {
          rtemp = std::min(std::pow(var / con3, .25), var/ (k	          rtemp = std::min(std::pow(var / con3, .25), var/ (k
          QWData(rho, rtemp,Ye, OutData);		      |	          QWData(rho, rtemp, Ye, OutData);
        } else if (index == EOS::iE) {				        } else if (index == EOS::iE) {
          rtemp = std::min(std::pow(var / (3.0 * con3), .25),	          rtemp = std::min(std::pow(var / (3.0 * con3), .25),
          QWData(rho, rtemp,Ye, OutData);		      |	          QWData(rho, rtemp, Ye, OutData);
        }							        }
      return;							      return;
      }								      }
      QWData(rho, BrakT[1],Ye, OutData);		      |	      QWData(rho, BrakT[1], Ye, OutData);
      Real high = OutData(index);				      Real high = OutData(index);
      std::stringstream msg;					      std::stringstream msg;
      const char *varnames[] = {"e_int", "de_int/dT", "P_gas"	      const char *varnames[] = {"e_int", "de_int/dT", "P_gas"
      printf("1 ERR (%s): %.4e !<= %.4e !<= %.4e\n", varnames	      printf("1 ERR (%s): %.4e !<= %.4e !<= %.4e\n", varnames
             high);						             high);
      printf("at rho = %.4e, T_bounds = %.4e, %.4e,\n", rho, 	      printf("at rho = %.4e, T_bounds = %.4e, %.4e,\n", rho, 

      msg << "### FATAL ERROR in EquationOfState inversion (T	      msg << "### FATAL ERROR in EquationOfState inversion (T
          << std::endl << "Root not bracketed" << std::endl;	          << std::endl << "Root not bracketed" << std::endl;
      ATHENA_ERROR(msg);					      ATHENA_ERROR(msg);
    }								    }

    if (std::abs(error) > 1e-2) {				    if (std::abs(error) > 1e-2) {
      // secant method step					      // secant method step
      delta = error * (GuessTemp - LastTemp) / (error - LastE	      delta = error * (GuessTemp - LastTemp) / (error - LastE
      LastTemp = GuessTemp;					      LastTemp = GuessTemp;
      GuessTemp -= delta;					      GuessTemp -= delta;
      //if(std::isnan(GuessTemp)){				      //if(std::isnan(GuessTemp)){
      //  std::cout<<"Nan in secant   "<<rho<<"     "<<delta<	      //  std::cout<<"Nan in secant   "<<rho<<"     "<<delta<
      //           <<"    "<<GuessTemp<<"    "<<LastTemp<<"  	      //           <<"    "<<GuessTemp<<"    "<<LastTemp<<"  
      //}							      //}
      LastErr = error;						      LastErr = error;
#ifdef MYDEBUG1							#ifdef MYDEBUG1
      mode = 2;							      mode = 2;
#endif								#endif
    } else {							    } else {
      // Newton–Raphson step					      // Newton–Raphson step
      delta = var * error / OutData(index + 1);			      delta = var * error / OutData(index + 1);
      GuessTemp -= delta;					      GuessTemp -= delta;
      //if(std::isnan(GuessTemp)){				      //if(std::isnan(GuessTemp)){
      //  std::cout<<"Nan in NR  "<<OutData(index+1)<<"    "<	      //  std::cout<<"Nan in NR  "<<OutData(index+1)<<"    "<
      //}							      //}
#ifdef MYDEBUG1							#ifdef MYDEBUG1
      mode = 3;							      mode = 3;
#endif								#endif
    }								    }

    if (nlim-- < 0) {						    if (nlim-- < 0) {
      Real rtemp;						      Real rtemp;
      if (index == EOS::iP) {					      if (index == EOS::iP) {
        rtemp = std::min(std::pow(var / con3, .25), var/ (kmn	        rtemp = std::min(std::pow(var / con3, .25), var/ (kmn
        QWData(rho, rtemp,Ye, OutData);			      |	        QWData(rho, rtemp, Ye, OutData);
        //std::cout<<"Var:pres, nlim reached   "<<rho<<"    "	        //std::cout<<"Var:pres, nlim reached   "<<rho<<"    "
      } else if (index == EOS::iE) {				      } else if (index == EOS::iE) {
        rtemp = std::min(std::pow(var / (3.0 * con3), .25), v	        rtemp = std::min(std::pow(var / (3.0 * con3), .25), v
        QWData(rho, rtemp,Ye, OutData);			      |	        QWData(rho, rtemp, Ye, OutData);
        //std::cout<<"Var:egas, nlim reached   "<<rho<<"    "	        //std::cout<<"Var:egas, nlim reached   "<<rho<<"    "
      }								      }
      return;							      return;
    }								    }
  }								  }

  if (OutData(5) < Tmin) {					  if (OutData(5) < Tmin) {
    Real rtemp;							    Real rtemp;
    if (index == EOS::iP) {					    if (index == EOS::iP) {
      rtemp = std::min(std::pow(var / con3, .25), var/ (kmn *	      rtemp = std::min(std::pow(var / con3, .25), var/ (kmn *
      QWData(rho, rtemp,Ye, OutData);			      |	      QWData(rho, rtemp, Ye, OutData);
      //std::cout<<"Var:pres, T<Tmin   "<<rho<<"    "<<var<<"	      //std::cout<<"Var:pres, T<Tmin   "<<rho<<"    "<<var<<"
    } else if (index == EOS::iE) {				    } else if (index == EOS::iE) {
      rtemp = std::min(std::pow(var / (3.0 * con3), .25), var	      rtemp = std::min(std::pow(var / (3.0 * con3), .25), var
      QWData(rho, rtemp,Ye, OutData);			      |	      QWData(rho, rtemp, Ye, OutData);
      //std::cout<<"Var:egas, T<Tmin   "<<rho<<"    "<<var<<"	      //std::cout<<"Var:egas, T<Tmin   "<<rho<<"    "<<var<<"
    }								    }

    //std::cout<<rho<<"   Return_temp < Tmin encountered, ret	    //std::cout<<rho<<"   Return_temp < Tmin encountered, ret
    return;							    return;
  }								  }
  if (std::isnan(OutData(5))) {					  if (std::isnan(OutData(5))) {
    //const char *varnames[] = {"e_int", "de_int/dT", "P_gas"	    //const char *varnames[] = {"e_int", "de_int/dT", "P_gas"
    //printf("ERR (%s): %.4e, rho: %.4e \n", varnames[index],	    //printf("ERR (%s): %.4e, rho: %.4e \n", varnames[index],
    Real rtemp;							    Real rtemp;
    if (index == EOS::iP) {					    if (index == EOS::iP) {
      rtemp = std::min(std::pow(var / con3, .25), var/ (kmn *	      rtemp = std::min(std::pow(var / con3, .25), var/ (kmn *
      QWData(rho, rtemp,Ye, OutData);			      |	      QWData(rho, rtemp, Ye, OutData);
      //std::cout<<"Var:pres, T nan   "<<rho<<"    "<<var<<" 	      //std::cout<<"Var:pres, T nan   "<<rho<<"    "<<var<<" 
    } else if (index == EOS::iE) {				    } else if (index == EOS::iE) {
      rtemp = std::min(std::pow(var / (3.0 * con3), .25), var	      rtemp = std::min(std::pow(var / (3.0 * con3), .25), var
      QWData(rho, rtemp,Ye, OutData);			      |	      QWData(rho, rtemp, Ye, OutData);
      //std::cout<<"Var:egas, T nan   "<<rho<<"    "<<var<<" 	      //std::cout<<"Var:egas, T nan   "<<rho<<"    "<<var<<" 
    }								    }
    return;							    return;
  }								  }

  //if(nmax-nlim>100){std::cout<<"Iter     "<<nmax-nlim<<"\n"	  //if(nmax-nlim>100){std::cout<<"Iter     "<<nmax-nlim<<"\n"
  return;							  return;
}								}

//-----------------------------------------------------------	//-----------------------------------------------------------
//! \fn Real EquationOfState::PresFromRhoEg(Real rho, Real eg	//! \fn Real EquationOfState::PresFromRhoEg(Real rho, Real eg
//  \brief Return gas pressure					//  \brief Return gas pressure
Real EquationOfState::PresFromRhoEg(Real rho, Real egas, Real	Real EquationOfState::PresFromRhoEg(Real rho, Real egas, Real
  Real ye = fixed_ye;						  Real ye = fixed_ye;
							      <
  if (NSCALARS > 0 && i_ye >= 0) {				  if (NSCALARS > 0 && i_ye >= 0) {
							      |	    ye = s[i_ye] / rho;
      ye = s[i_ye]/rho;					      |	  }
   							      <
   }							      <
  //std::cout<<"In EOS Presfromrhoeg   "<<ye<<"\n";	      <
  TempInvert(rho, LastTemp, ye, egas, EOS::iE, EosData);	  TempInvert(rho, LastTemp, ye, egas, EOS::iE, EosData);
  LastTemp = EosData(EOS::iT);					  LastTemp = EosData(EOS::iT);
  return EosData(EOS::iP);					  return EosData(EOS::iP);
}								}

//-----------------------------------------------------------	//-----------------------------------------------------------
//! \fn Real EquationOfState::EgasFromRhoP(Real rho, Real pre	//! \fn Real EquationOfState::EgasFromRhoP(Real rho, Real pre
//  \brief Return internal energy density			//  \brief Return internal energy density
Real EquationOfState::EgasFromRhoP(Real rho, Real pres, Real*	Real EquationOfState::EgasFromRhoP(Real rho, Real pres, Real*
  Real ye = fixed_ye;						  Real ye = fixed_ye;
  if (NSCALARS > 0 && i_ye >= 0) {				  if (NSCALARS > 0 && i_ye >= 0) {
							      |	    ye = r[i_ye];
      ye = r[i_ye];					      |	  }
  }   							      <
  //std::cout<<"In EOS egasfromrhoP   "<<ye<<"\n";	      <
  TempInvert(rho, LastTemp, ye, pres, EOS::iP, EosData);	  TempInvert(rho, LastTemp, ye, pres, EOS::iP, EosData);
  LastTemp = EosData(EOS::iT);					  LastTemp = EosData(EOS::iT);
  return EosData(EOS::iE);					  return EosData(EOS::iE);
}								}

//-----------------------------------------------------------	//-----------------------------------------------------------
//! \fn Real EquationOfState::AsqFromRhoP(Real rho, Real pres	//! \fn Real EquationOfState::AsqFromRhoP(Real rho, Real pres
//  \brief Return adiabatic sound speed squared			//  \brief Return adiabatic sound speed squared
Real EquationOfState::AsqFromRhoP(Real rho, Real pres, const 	Real EquationOfState::AsqFromRhoP(Real rho, Real pres, const 
  Real ye = fixed_ye;						  Real ye = fixed_ye;
  if (NSCALARS > 0 && i_ye >= 0) {			      |	//  if (NSCALARS > 0 && i_ye >= 0) {
							      >	//    ye = r[i_ye];
							      >	//  }

							      >	  if (NSCALARS > 0 && i_ye >= 0) {
							      >	    if((r[i_ye]<0.0) || (r[i_ye]>1.0)) {
							      >	      ye=1e-3;
							      >	    }
							      >	    else {
      ye = r[i_ye];						      ye = r[i_ye];
  							      |	    }
  }								  }
  //std::cout<<"In EOS Asq   "<<ye<<"\n";		      <
  TempInvert(rho, LastTemp, ye, pres, EOS::iP, EosData);	  TempInvert(rho, LastTemp, ye, pres, EOS::iP, EosData);
  LastTemp = EosData(EOS::iT);					  LastTemp = EosData(EOS::iT);
  return EosData(EOS::iAsq);					  return EosData(EOS::iAsq);
}							      <

void EquationOfState::SevenFromRhoT(Real rho, Real T, AthenaA |	//  if((r[i_ye]<0.0) || (r[i_ye]>1.0)) {
  Real ye = fixed_ye;					      |	//    ye=1e-3;
  if (NSCALARS > 0 && i_ye >= 0) {			      |	//  }
    ye = r[i_ye];					      |	//  else {
  }							      |	//    ye = r[i_ye];
  QWData(rho, T, ye, out);				      |	//  }
}								}

							      >	//! THIS PROBABLY DOESNT WORK
Real EquationOfState::TFromRhoP(Real rho, Real pres, Real* r)	Real EquationOfState::TFromRhoP(Real rho, Real pres, Real* r)
  Real ye = fixed_ye;						  Real ye = fixed_ye;
  if (NSCALARS > 0 && i_ye >= 0) {				  if (NSCALARS > 0 && i_ye >= 0) {
    ye = r[i_ye];						    ye = r[i_ye];
  }								  }
  TempInvert(rho, LastTemp, ye, pres, EOS::iP, EosData);	  TempInvert(rho, LastTemp, ye, pres, EOS::iP, EosData);
  LastTemp = EosData(EOS::iT);					  LastTemp = EosData(EOS::iT);
  return LastTemp;						  return LastTemp;
}								}

Real EquationOfState::TFromRhoEgas(Real rho, Real egas, Real* |	//! THIS PROBABLY DOESNT WORK
							      >	Real EquationOfState::PresFromRhoT(Real rho, Real T, Real* r)
  Real ye = fixed_ye;						  Real ye = fixed_ye;
  if (NSCALARS > 0 && i_ye >= 0) {				  if (NSCALARS > 0 && i_ye >= 0) {
    ye = s[i_ye] / rho;					      |	    ye = r[i_ye];
  }								  }
  TempInvert(rho, LastTemp, ye, egas, EOS::iE, EosData);      |	  QWData(rho, T, ye, EosData);
							      >	  return EosData(EOS::iP);
							      >	}
							      >
							      >	// Putting these here just to get things to compile (These ar
							      >	// but I don't use either of those for my accretion problem).
							      >	Real EquationOfState::TFromRhoP(Real rho, Real pres) {
							      >	  Real ye = fixed_ye;
							      >	//  std::cout << "test1" << std::endl;
							      >	  TempInvert(rho, LastTemp, ye, pres, EOS::iP, EosData);
  LastTemp = EosData(EOS::iT);					  LastTemp = EosData(EOS::iT);
  return LastTemp;						  return LastTemp;
}								}

Real EquationOfState::PresFromRhoT(Real rho, Real T, Real* r) |	Real EquationOfState::PresFromRhoT(Real rho, Real T) {
  Real ye = fixed_ye;						  Real ye = fixed_ye;
  if (NSCALARS > 0 && i_ye >= 0) {			      |	//  std::cout << "test2" << std::endl;
    ye = r[i_ye];					      <
  }							      <
  QWData(rho, T, ye, EosData);					  QWData(rho, T, ye, EosData);
  return EosData(EOS::iP);					  return EosData(EOS::iP);
}								}

Real EquationOfState::GetEgasFloor(Real rho, Real* s) {	      |
  Real ye = fixed_ye;					      |	#if 0
  if (NSCALARS > 0 && i_ye >= 0) {			      |	void EquationOfState::SevenFromRhoT(Real rho, Real T, AthenaA
    ye = s[i_ye] / rho;					      |	  QWData(rho, T, out);
  }							      |	}
  QWData(rho, T_floor, ye, EosData);			      |
							      >	Real EquationOfState::TFromRhoP(Real rho, Real pres) {
							      >	  TempInvert(rho, LastTemp, pres, EOS::iP, EosData);
							      >	  LastTemp = EosData(EOS::iT);
							      >	  return LastTemp;
							      >	}
							      >
							      >	Real EquationOfState::TFromRhoEgas(Real rho, Real egas) {
							      >	  TempInvert(rho, LastTemp, egas, EOS::iE, EosData);
							      >	  LastTemp = EosData(EOS::iT);
							      >	  return LastTemp;
							      >	}
							      >
							      >	Real EquationOfState::PresFromRhoT(Real rho, Real T) {
							      >	  QWData(rho, T, EosData);
							      >	  return EosData(EOS::iP);
							      >	}
							      >
							      >	Real EquationOfState::GetEgasFloor(Real rho) {
							      >	  QWData(rho, T_floor, EosData);
  return EosData(EOS::iE);					  return EosData(EOS::iE);
  							      <
}								}

Real EquationOfState::GetPresFloor(Real rho, Real* r) {	      |	Real EquationOfState::GetPresFloor(Real rho) {
  Real ye = fixed_ye;					      |	  QWData(rho, T_floor, EosData);
  if (NSCALARS > 0 && i_ye >= 0) {			      <
    ye = r[i_ye];					      <
  }							      <
  QWData(rho, T_floor, ye, EosData);			      <
  return EosData(EOS::iP);					  return EosData(EOS::iP);
  							      <
}								}
							      >	#endif

//-----------------------------------------------------------	//-----------------------------------------------------------
//! \fn void EquationOfState::InitEosConstants(ParameterInput	//! \fn void EquationOfState::InitEosConstants(ParameterInput
//! \brief Initialize constants for EOS				//! \brief Initialize constants for EOS
void EquationOfState::InitEosConstants(ParameterInput* pin) {	void EquationOfState::InitEosConstants(ParameterInput* pin) {
  EosData.NewAthenaArray(EOS::N);				  EosData.NewAthenaArray(EOS::N);
  prec = pin->GetOrAddReal("hydro", "InversionPrecision", pre	  prec = pin->GetOrAddReal("hydro", "InversionPrecision", pre
  if (pin->DoesParameterExist("hydro", "eos_ye")) {		  if (pin->DoesParameterExist("hydro", "eos_ye")) {
    fixed_ye = pin->GetReal("hydro", "eos_ye");			    fixed_ye = pin->GetReal("hydro", "eos_ye");
  }								  }
  if (pin->DoesParameterExist("hydro", "eos_ye_index")) {	  if (pin->DoesParameterExist("hydro", "eos_ye_index")) {
    i_ye = pin->GetInteger("hydro", "eos_ye_index");		    i_ye = pin->GetInteger("hydro", "eos_ye_index");
    if (i_ye < 0 || i_ye >= NSCALARS) {				    if (i_ye < 0 || i_ye >= NSCALARS) {
      std::stringstream msg;					      std::stringstream msg;
      msg << "### FATAL ERROR in EquationOfState::InitEosCons	      msg << "### FATAL ERROR in EquationOfState::InitEosCons
          << "hydro/eos_ye_index must be between 0 and NSCALA	          << "hydro/eos_ye_index must be between 0 and NSCALA
          << std::endl;						          << std::endl;
      ATHENA_ERROR(msg);					      ATHENA_ERROR(msg);
    }								    }
  }								  }
  if (fixed_ye < 0 && i_ye < 0) {				  if (fixed_ye < 0 && i_ye < 0) {
    std::stringstream msg;					    std::stringstream msg;
    msg << "### FATAL ERROR in EquationOfState::InitEosConsta	    msg << "### FATAL ERROR in EquationOfState::InitEosConsta
        << "either hydro/eos_ye or hydro/eos_ye_index must be	        << "either hydro/eos_ye or hydro/eos_ye_index must be
        << std::endl;						        << std::endl;
    ATHENA_ERROR(msg);						    ATHENA_ERROR(msg);
  }								  }
  T_floor = pin->GetOrAddReal("hydro", "T_floor", Tmin);	  T_floor = pin->GetOrAddReal("hydro", "T_floor", Tmin);
  T_ceil = pin->GetOrAddReal("hydro", "T_ceil", Tmax);		  T_ceil = pin->GetOrAddReal("hydro", "T_ceil", Tmax);
  if(T_floor<Tmin){					      |	  if (T_floor<Tmin) {
    T_floor=Tmin;						    T_floor=Tmin;
  }								  }
  std::cout<<"T floor and ceil   "<<T_floor<<"   "<<T_ceil<<"	  std::cout<<"T floor and ceil   "<<T_floor<<"   "<<T_ceil<<"
  use_T_floor = pin->GetOrAddBoolean("hydro", "use_T_floor", 	  use_T_floor = pin->GetOrAddBoolean("hydro", "use_T_floor", 
  LastTemp = pin->GetOrAddReal("hydro", "T0", std::sqrt(T_flo	  LastTemp = pin->GetOrAddReal("hydro", "T0", std::sqrt(T_flo
  nmax = pin->GetOrAddInteger("hydro", "nmax", 10000);		  nmax = pin->GetOrAddInteger("hydro", "nmax", 10000);
  // if root processor and zeroth block			      <
  if ((Globals::my_rank == 0) && (pmy_block_->lid == 0)) {    <
    //std::cout<<Ye<<" Ye\n";				      <
    std::cout<<"Using updated EOS QW NEW 3 \n";		      <
  }							      <
  #ifdef MYDEBUG						  #ifdef MYDEBUG
    Real rho, temp;						    Real rho, temp;
    std::cout << "Input fluid parameters and retrieve EOS par	    std::cout << "Input fluid parameters and retrieve EOS par
              << "Non-positive inputs will exit loop." << '\n	              << "Non-positive inputs will exit loop." << '\n
    std::cout << "Input density (mass/volume): ";		    std::cout << "Input density (mass/volume): ";
    std::cin >> rho;						    std::cin >> rho;
    std::cout << "Input temperature (K): ";			    std::cout << "Input temperature (K): ";
    std::cin >> temp;						    std::cin >> temp;

    while (rho > 0 && std::isfinite(rho) && temp > 0 && std::	    while (rho > 0 && std::isfinite(rho) && temp > 0 && std::
      printf("d, t: %.16e, %.16e\n", rho, temp);		      printf("d, t: %.16e, %.16e\n", rho, temp);
      QWData(rho, temp, EosData);				      QWData(rho, temp, EosData);
      Real p = EosData(EOS::iP);				      Real p = EosData(EOS::iP);
      Real e = EosData(EOS::iE);				      Real e = EosData(EOS::iE);
      Real a2 = EosData(EOS::iAsq);				      Real a2 = EosData(EOS::iAsq);
      Real P_tejas = compare::P_of_rho_T(rho, temp);		      Real P_tejas = compare::P_of_rho_T(rho, temp);
      Real e_tejas = compare::e_of_rho_T(rho, temp);		      Real e_tejas = compare::e_of_rho_T(rho, temp);
      Real Asq_tejas = compare::asq(rho, temp, P_tejas);	      Real Asq_tejas = compare::asq(rho, temp, P_tejas);
      printf("e(d, T)          , p(d, T)         , ASq(d, T)\	      printf("e(d, T)          , p(d, T)         , ASq(d, T)\
      printf("%.16e, %.16e, %.16e\n", e, p, a2);		      printf("%.16e, %.16e, %.16e\n", e, p, a2);
      printf("e_matt/e_tejas-1, P_matt/P_tejas-1, Asq_matt/As	      printf("e_matt/e_tejas-1, P_matt/P_tejas-1, Asq_matt/As
      printf("%.16e, %.16e, %.16e\n", e/e_tejas-1.0, p/P_teja	      printf("%.16e, %.16e, %.16e\n", e/e_tejas-1.0, p/P_teja
      Real Te = TFromRhoEgas(rho, e);				      Real Te = TFromRhoEgas(rho, e);
      Real Tp = TFromRhoP(rho, p);				      Real Tp = TFromRhoP(rho, p);
      printf("T(d, e)/T-1, T(d, p)/T-1\n");			      printf("T(d, e)/T-1, T(d, p)/T-1\n");
      printf("%.16e, %.16e\n", Te/temp - 1.0, Tp/temp - 1.0);	      printf("%.16e, %.16e\n", Te/temp - 1.0, Tp/temp - 1.0);
      std::cout << "Input density (mass/volume): ";		      std::cout << "Input density (mass/volume): ";
      std::cin >> rho;						      std::cin >> rho;
      std::cout << "Input temperature (K): ";			      std::cout << "Input temperature (K): ";
      std::cin >> temp;						      std::cin >> temp;
    }								    }
    std::cout << std::endl;					    std::cout << std::endl;
  #endif							  #endif
  return;							  return;
}								}
							      <
							      <

